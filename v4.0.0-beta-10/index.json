[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/WebAudio/AudioContext.js",
    "content": "import debug from 'debug';\n\n/**\n * Recorder\n * Simple Audio Recorder based on WebAudio technology\n */\nexport default class AudioContext {\n  /**\n   * Construct the Player.\n   *\n   * @param {Object} audioContext - Allow to provide custom/own audioContext object.\n   * @param {string} debugNameSpace - Name to be used for debugging.\n   */\n  constructor(audioContext = null, debugNameSpace = 'AudioContext') {\n    /**\n     * Private object to hold AudioContext node.\n     * @type {AudioContext}\n     */\n    this.audioContext = null;\n\n    /**\n     * This will be the log function.\n     * Will output to stdout.\n     * @type {Function}\n     */\n    this.log = null;\n\n    /**\n     * This will be the error function.\n     * Will output to stderr.\n     * @type {Function}\n     */\n    this.error = null;\n\n    /**\n     * Keep a list of all registered event listeners.\n     * This way, we could conveniently remove all the listeners at once.\n     * @type {Array}\n     */\n    this.eventListeners = [];\n\n    // Provide AudioContext object. If not passed the\n    // default window.AudioContext will be used.\n    if (audioContext) {\n      this.audioContext = audioContext;\n    } else {\n      this.audioContext = this.createAudioContext();\n    }\n\n    // Prepare the log and error function to be used!\n    this.log = debug(`its-sdk:${debugNameSpace}`);\n    this.error = debug(`its-sdk:${debugNameSpace}`);\n\n    // Bind log to stdout in stead of stderr\n    this.log.log = console.log.bind(console);\n\n    this.suspendAudioContext = this.suspendAudioContext.bind(this);\n  }\n\n  /**\n   * Wraps the addEventListener which is available on the AudioContext node.\n   * Note that it is required to pass a named function to actually be able\n   * to remove an event listeners. This is just how the EventTarget.removeEventListener\n   * works. There are no extra checks for.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/attachEvent\n   * @param {...*} args - Array with passed arguments.\n   */\n  addEventListener(...args) {\n    // First, add the event listener to our local list.\n    this.eventListeners.push(args);\n\n    // Now, actually add the event listener!\n    this.audioContext.addEventListener(...args);\n  }\n\n  /**\n   * Wraps the removeEventListener which is available on the AudioContext node.\n   * Make sure to call with the same arguments as the addEventListener.\n   *\n   * If you didn't call the addEventListener with a named function, please note\n   * that you won't be able to remove the eventListener.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener\n   * @param {...*} args - Array with passed arguments.\n   */\n  removeEventListener(...args) {\n    // First, try to find the event in our list.\n    const itemIndex = this.eventListeners.findIndex((item) => {\n      // If the count of items doesn't equal, it's definitely not the\n      // listener we want to remove.\n      if (item.length !== args.length) {\n        return false;\n      }\n\n      // Now we're gonna loop through the items to check if we can\n      // find an item which does not compare equal. If we find one\n      // 'some' will immediately return true and the party is over!\n      // Wubba lubba dub dub!\n      return !args.some((arg, index) => item[index] !== arg);\n    });\n\n    // Remove that item, and only that one, from the list\n    if (itemIndex) {\n      this.eventListeners.splice(itemIndex, 1);\n    }\n\n    // Remove the event handler!\n    this.audioContext.removeEventListener(...args);\n  }\n\n  removeAllEventListeners() {\n    this.eventListeners.forEach((listener) => {\n      this.removeEventListener(...listener);\n    });\n    this.eventListeners = [];\n  }\n\n  /**\n   * Use this method to conveniently fire an event.\n   * We could, if we wanted, add some data.\n   *\n   * @param {string} eventName - Event to fire.\n   * @param {Object} data - Data to pass as detail.\n   */\n  fireEvent(eventName, data = null) {\n    if (!eventName) {\n      return;\n    }\n    const customEvent = new CustomEvent(eventName, { detail: data });\n    this.audioContext.dispatchEvent(customEvent);\n  }\n\n  /**\n   * Get the audio context or create one.\n   *\n   * @return {AudioContext} The AudioContext created will be returned.\n   */\n  static createAudioContext() {\n    if (!window.ItslAudioContext) {\n      window.AudioContext = window.AudioContext || window.webkitAudioContext;\n      window.ItslAudioContext = new window.AudioContext();\n    }\n    return window.ItslAudioContext;\n  }\n\n  /**\n   * Suspend the AudioContext to preserve power and such.\n   */\n  suspendAudioContext() {\n    this.audioContext.suspend();\n  }\n\n  /**\n   * Resume a suspended AudioContext.\n   */\n  resumeAudioContext() {\n    if (this.audioContext.state === 'suspended') {\n      this.audioContext.resume();\n    }\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/WebAudio/AudioContext.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "AudioContext",
    "memberof": "src/WebAudio/AudioContext.js",
    "static": true,
    "longname": "src/WebAudio/AudioContext.js~AudioContext",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/WebAudio/AudioContext.js",
    "importStyle": "AudioContext",
    "description": "Recorder\nSimple Audio Recorder based on WebAudio technology",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#constructor",
    "access": "public",
    "description": "Construct the Player.",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "audioContext",
        "description": "Allow to provide custom/own audioContext object."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "debugNameSpace",
        "description": "Name to be used for debugging."
      }
    ]
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "audioContext",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#audioContext",
    "access": "public",
    "description": "Private object to hold AudioContext node.",
    "lineNumber": 19,
    "type": {
      "nullable": null,
      "types": [
        "AudioContext"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "log",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#log",
    "access": "public",
    "description": "This will be the log function.\nWill output to stdout.",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "Function"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "error",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#error",
    "access": "public",
    "description": "This will be the error function.\nWill output to stderr.",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "Function"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "eventListeners",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#eventListeners",
    "access": "public",
    "description": "Keep a list of all registered event listeners.\nThis way, we could conveniently remove all the listeners at once.",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 60,
    "kind": "method",
    "name": "addEventListener",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#addEventListener",
    "access": "public",
    "description": "Wraps the addEventListener which is available on the AudioContext node.\nNote that it is required to pass a named function to actually be able\nto remove an event listeners. This is just how the EventTarget.removeEventListener\nworks. There are no extra checks for.",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/attachEvent"
    ],
    "lineNumber": 69,
    "params": [
      {
        "nullable": null,
        "types": [
          "...*"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Array with passed arguments."
      }
    ],
    "return": null
  },
  {
    "__docId__": 61,
    "kind": "method",
    "name": "removeEventListener",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#removeEventListener",
    "access": "public",
    "description": "Wraps the removeEventListener which is available on the AudioContext node.\nMake sure to call with the same arguments as the addEventListener.\n\nIf you didn't call the addEventListener with a named function, please note\nthat you won't be able to remove the eventListener.",
    "see": [
      "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener"
    ],
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "...*"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Array with passed arguments."
      }
    ],
    "return": null
  },
  {
    "__docId__": 62,
    "kind": "method",
    "name": "removeAllEventListeners",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#removeAllEventListeners",
    "access": "public",
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 64,
    "kind": "method",
    "name": "fireEvent",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#fireEvent",
    "access": "public",
    "description": "Use this method to conveniently fire an event.\nWe could, if we wanted, add some data.",
    "lineNumber": 126,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "eventName",
        "description": "Event to fire."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Data to pass as detail."
      }
    ],
    "return": null
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "createAudioContext",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/WebAudio/AudioContext.js~AudioContext.createAudioContext",
    "access": "public",
    "description": "Get the audio context or create one.",
    "lineNumber": 139,
    "return": {
      "nullable": null,
      "types": [
        "AudioContext"
      ],
      "spread": false,
      "description": "The AudioContext created will be returned."
    },
    "params": []
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "suspendAudioContext",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#suspendAudioContext",
    "access": "public",
    "description": "Suspend the AudioContext to preserve power and such.",
    "lineNumber": 150,
    "params": [],
    "return": null
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "resumeAudioContext",
    "memberof": "src/WebAudio/AudioContext.js~AudioContext",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/AudioContext.js~AudioContext#resumeAudioContext",
    "access": "public",
    "description": "Resume a suspended AudioContext.",
    "lineNumber": 157,
    "params": [],
    "return": null
  },
  {
    "__docId__": 68,
    "kind": "file",
    "name": "src/WebAudio/Player.js",
    "content": "import { authorisedRequest, request } from '../api/communication';\nimport AudioContext from './AudioContext';\n\n/**\n * Player\n * Simple Audio Player based on Web Audio API technology\n */\nexport default class Player extends AudioContext {\n  /**\n   * Private object to hold AudioBuffer node.\n   * @private\n   * @Type {AudioBuffer}\n   */\n  audioBuffer = null;\n\n  /**\n   * Private object to hold AudioBufferSourceNode node.\n   * @private\n   * @type {AudioBufferSourceNode}\n   */\n  audioSource = null;\n\n  /**\n   * Private object to hold GainNode.\n   * @private\n   * @type {GainNode}\n   */\n  gainNode = null;\n\n  /**\n   * Player playback state.\n   * @private\n   * @type {boolean}\n   */\n  playing = false;\n\n  /**\n   * Player volume. 0 is muted, 1 is 100%.\n   * @type {number}\n   */\n  volume = 1;\n\n  /**\n   * Point in time where player is paused.\n   * @private\n   * @type {number}\n   */\n  pausedAt = 0;\n\n  /**\n   * Point in time where player is started\n   * @private\n   * @type {number}\n   */\n  startedAt = 0;\n\n  /**\n   * Player constructor.\n   * Creates a GainNode and stores it.\n   */\n  constructor() {\n    super();\n\n    this.gainNode = this.audioContext.createGain();\n    this.gainNode.gain.value = this.volume;\n    this.gainNode.connect(this.audioContext.destination);\n  }\n\n  /**\n   * Create and initialize the AudioBufferSourceNode object.\n   *\n   */\n  createBufferSource() {\n    this.disconnectBufferSource();\n\n    // Create a sound source\n    this.audioSource = this.audioContext.createBufferSource();\n\n    // Select what to play\n    this.audioSource.buffer = this.audioBuffer;\n\n    // Connect to the GainNode!\n    this.audioSource.connect(this.gainNode);\n\n    // Add some event handlers;\n    this.audioSource.addEventListener('ended', () => {\n      // Do not fire ended if player is paused!\n      if (!this.pausedAt) {\n        this.fireEvent('ended');\n        this.suspendAudioContext();\n      }\n    });\n\n    this.fireEvent('loaded');\n  }\n\n  /**\n   * Disconnect the AudioBufferSourceNode.\n   *\n   */\n  disconnectBufferSource() {\n    if (this.audioSourceExists()) {\n      this.audioSource.disconnect();\n      this.audioSource = null;\n    }\n  }\n\n  /**\n   * Get an audio stream from an URL.\n   *\n   * If the withItslToken is provided (and set to true) use the authorizedRequest method to load\n   * the audio. This in effect will set the ITSLanguage bearer token (if available) to the request.\n   *\n   * For both request methods goes: there's no check whether you're trying to load from ITSLanguage\n   * backend system or not.\n   *\n   * @param {string} url - Url to load.\n   * @param {boolean} withItslToken - Make use of authorizedRequest or just request if set to false.\n   */\n  load(url, withItslToken = true) {\n    if (!url) {\n      return;\n    }\n\n    // Determine whether to ask authorized, or not.\n    const requestMethod = withItslToken ? authorisedRequest : request;\n    const { audioContext } = this;\n\n    requestMethod('GET', url)\n      .then(response => response.arrayBuffer())\n      .then(audioData => audioContext.decodeAudioData(audioData, (decodedAudio) => {\n        this.audioBuffer = decodedAudio;\n        this.createBufferSource();\n      }))\n      .catch((error) => {\n        this.error(`${error.name}: ${error.message}`);\n      });\n  }\n\n  /**\n   * Returns if the audioBuffer has been created and loaded, or not.\n\n   * @returns {boolean} The audioBuffer created.\n   */\n  audioBufferExists() {\n    return Boolean(this.audioBuffer);\n  }\n\n  /**\n   * Return if audioSource has been created, or not.\n   *\n   * @returns {boolean} The audioSource created.\n   */\n  audioSourceExists() {\n    return Boolean(this.audioSource);\n  }\n\n  /**\n   * Start audio playback of that what is in the buffer.\n   */\n  play() {\n    const offset = this.pausedAt;\n\n    if (offset !== 0) {\n      this.createBufferSource();\n    }\n\n    if (this.audioContext.state === 'suspended') {\n      this.audioContext.resume();\n    }\n\n    // play the source now\n    this.audioSource.start(0, offset);\n\n    this.startedAt = this.audioContext.currentTime - offset;\n    this.pausedAt = 0;\n    this.playing = true;\n\n    this.fireEvent('playing');\n  }\n\n  /**\n   * Stop playback of audio.\n   * Check for buffer and source to exist, if not, exit.\n   */\n  stop() {\n    if (!this.audioBufferExists() && !this.audioSourceExists()) {\n      return;\n    }\n\n    this.audioSource.stop();\n    this.pausedAt = 0;\n    this.startedAt = 0;\n    this.playing = false;\n\n    this.fireEvent('stopped');\n  }\n\n  /**\n   * Pause playback of audio.\n   */\n  pause() {\n    if (!this.audioBufferExists() && !this.audioSourceExists()) {\n      return;\n    }\n\n    const elapsed = this.audioContext.currentTime - this.startedAt;\n    this.audioSource.stop();\n    this.pausedAt = elapsed;\n\n    this.fireEvent('pause');\n  }\n\n  /**\n   * Is the player currently playing.\n   *\n   * @returns {boolean} - Whether or not the player is playing audio.\n   */\n  isPlaying() {\n    return this.playing;\n  }\n\n  /**\n   * Get the duration of the loaded audio.\n   *\n   * @returns {number} - Duration of the loaded audio.\n   */\n  getDuration() {\n    return this.audioBuffer.duration;\n  }\n\n  /**\n   * Set the volume of the payer to a value between 0 - 1.\n   * 0 means no volume (muted), 1 means max.\n   *\n   * @param {number} volume - Value for volume between 0 an 1.\n   */\n  setVolume(volume = 1) {\n    this.volume = volume;\n    this.gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);\n  }\n\n  /**\n   * Mute the player by setting its volume to 0.\n   */\n  mute() {\n    this.volume = 0;\n    this.gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);\n  }\n\n  /**\n   * Get the currentTime for the audio that is loaded.\n   *\n   * @returns {number} - The currentTime value.\n   */\n  getCurrentTime() {\n    if (this.pausedAt) {\n      return this.pausedAt;\n    }\n\n    if (this.startedAt) {\n      return this.audioContext.currentTime - this.startedAt;\n    }\n\n    return 0;\n  }\n\n  /**\n   * Return the AudioBufferSourceNode node.\n   * Note that after a pause/resume the AudioBufferSourceNode will be recreated.\n   *\n   * @returns {AudioBufferSourceNode} - The current available AudioBufferSourceNode.\n   */\n  getBufferSource() {\n    return this.audioSource;\n  }\n\n  /**\n   * Return the AudioContext node.\n   *\n   * @returns {AudioContext} - The current available AudioContext.\n   */\n  getAudioContext() {\n    return this.audioContext;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/WebAudio/Player.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 69,
    "kind": "class",
    "name": "Player",
    "memberof": "src/WebAudio/Player.js",
    "static": true,
    "longname": "src/WebAudio/Player.js~Player",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/WebAudio/Player.js",
    "importStyle": "Player",
    "description": "Player\nSimple Audio Player based on Web Audio API technology",
    "lineNumber": 8,
    "interface": false,
    "extends": [
      "src/WebAudio/AudioContext.js~AudioContext"
    ]
  },
  {
    "__docId__": 70,
    "kind": "member",
    "name": "audioBuffer",
    "memberof": "src/WebAudio/Player.js~Player",
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#audioBuffer",
    "access": "private",
    "description": "Private object to hold AudioBuffer node.",
    "lineNumber": 14,
    "unknown": [
      {
        "tagName": "@Type",
        "tagValue": "{AudioBuffer}"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 71,
    "kind": "member",
    "name": "audioSource",
    "memberof": "src/WebAudio/Player.js~Player",
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#audioSource",
    "access": "private",
    "description": "Private object to hold AudioBufferSourceNode node.",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "AudioBufferSourceNode"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 72,
    "kind": "member",
    "name": "gainNode",
    "memberof": "src/WebAudio/Player.js~Player",
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#gainNode",
    "access": "private",
    "description": "Private object to hold GainNode.",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "GainNode"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 73,
    "kind": "member",
    "name": "playing",
    "memberof": "src/WebAudio/Player.js~Player",
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#playing",
    "access": "private",
    "description": "Player playback state.",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 74,
    "kind": "member",
    "name": "volume",
    "memberof": "src/WebAudio/Player.js~Player",
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#volume",
    "access": "public",
    "description": "Player volume. 0 is muted, 1 is 100%.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 75,
    "kind": "member",
    "name": "pausedAt",
    "memberof": "src/WebAudio/Player.js~Player",
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#pausedAt",
    "access": "private",
    "description": "Point in time where player is paused.",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 76,
    "kind": "member",
    "name": "startedAt",
    "memberof": "src/WebAudio/Player.js~Player",
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#startedAt",
    "access": "private",
    "description": "Point in time where player is started",
    "lineNumber": 55,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 77,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#constructor",
    "access": "public",
    "description": "Player constructor.\nCreates a GainNode and stores it.",
    "lineNumber": 61
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "createBufferSource",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#createBufferSource",
    "access": "public",
    "description": "Create and initialize the AudioBufferSourceNode object.",
    "lineNumber": 73,
    "params": [],
    "return": null
  },
  {
    "__docId__": 81,
    "kind": "method",
    "name": "disconnectBufferSource",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#disconnectBufferSource",
    "access": "public",
    "description": "Disconnect the AudioBufferSourceNode.",
    "lineNumber": 101,
    "params": [],
    "return": null
  },
  {
    "__docId__": 83,
    "kind": "method",
    "name": "load",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#load",
    "access": "public",
    "description": "Get an audio stream from an URL.\n\nIf the withItslToken is provided (and set to true) use the authorizedRequest method to load\nthe audio. This in effect will set the ITSLanguage bearer token (if available) to the request.\n\nFor both request methods goes: there's no check whether you're trying to load from ITSLanguage\nbackend system or not.",
    "lineNumber": 120,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "Url to load."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "withItslToken",
        "description": "Make use of authorizedRequest or just request if set to false."
      }
    ],
    "return": null
  },
  {
    "__docId__": 85,
    "kind": "method",
    "name": "audioBufferExists",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#audioBufferExists",
    "access": "public",
    "description": "Returns if the audioBuffer has been created and loaded, or not.",
    "lineNumber": 145,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} The audioBuffer created."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "The audioBuffer created."
    },
    "params": []
  },
  {
    "__docId__": 86,
    "kind": "method",
    "name": "audioSourceExists",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#audioSourceExists",
    "access": "public",
    "description": "Return if audioSource has been created, or not.",
    "lineNumber": 154,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} The audioSource created."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "The audioSource created."
    },
    "params": []
  },
  {
    "__docId__": 87,
    "kind": "method",
    "name": "play",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#play",
    "access": "public",
    "description": "Start audio playback of that what is in the buffer.",
    "lineNumber": 161,
    "params": [],
    "return": null
  },
  {
    "__docId__": 91,
    "kind": "method",
    "name": "stop",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#stop",
    "access": "public",
    "description": "Stop playback of audio.\nCheck for buffer and source to exist, if not, exit.",
    "lineNumber": 186,
    "params": [],
    "return": null
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "pause",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#pause",
    "access": "public",
    "description": "Pause playback of audio.",
    "lineNumber": 202,
    "params": [],
    "return": null
  },
  {
    "__docId__": 97,
    "kind": "method",
    "name": "isPlaying",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#isPlaying",
    "access": "public",
    "description": "Is the player currently playing.",
    "lineNumber": 219,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} - Whether or not the player is playing audio."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "Whether or not the player is playing audio."
    },
    "params": []
  },
  {
    "__docId__": 98,
    "kind": "method",
    "name": "getDuration",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#getDuration",
    "access": "public",
    "description": "Get the duration of the loaded audio.",
    "lineNumber": 228,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - Duration of the loaded audio."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Duration of the loaded audio."
    },
    "params": []
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "setVolume",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#setVolume",
    "access": "public",
    "description": "Set the volume of the payer to a value between 0 - 1.\n0 means no volume (muted), 1 means max.",
    "lineNumber": 238,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "volume",
        "description": "Value for volume between 0 an 1."
      }
    ],
    "return": null
  },
  {
    "__docId__": 101,
    "kind": "method",
    "name": "mute",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#mute",
    "access": "public",
    "description": "Mute the player by setting its volume to 0.",
    "lineNumber": 246,
    "params": [],
    "return": null
  },
  {
    "__docId__": 103,
    "kind": "method",
    "name": "getCurrentTime",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#getCurrentTime",
    "access": "public",
    "description": "Get the currentTime for the audio that is loaded.",
    "lineNumber": 256,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - The currentTime value."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The currentTime value."
    },
    "params": []
  },
  {
    "__docId__": 104,
    "kind": "method",
    "name": "getBufferSource",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#getBufferSource",
    "access": "public",
    "description": "Return the AudioBufferSourceNode node.\nNote that after a pause/resume the AudioBufferSourceNode will be recreated.",
    "lineNumber": 274,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{AudioBufferSourceNode} - The current available AudioBufferSourceNode."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "AudioBufferSourceNode"
      ],
      "spread": false,
      "description": "The current available AudioBufferSourceNode."
    },
    "params": []
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "getAudioContext",
    "memberof": "src/WebAudio/Player.js~Player",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Player.js~Player#getAudioContext",
    "access": "public",
    "description": "Return the AudioContext node.",
    "lineNumber": 283,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{AudioContext} - The current available AudioContext."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "AudioContext"
      ],
      "spread": false,
      "description": "The current available AudioContext."
    },
    "params": []
  },
  {
    "__docId__": 106,
    "kind": "file",
    "name": "src/WebAudio/Recorder.js",
    "content": "import AudioContext from './AudioContext';\n\nconst DEFAULT_AUDIO_FORMAT = 'audio/wave';\nconst DEFAULT_CHANNELS = 1;\nconst DEFAULT_SAMPLE_WIDTH = 16;\nconst DEFAULT_SAMPLE_RATE = 48000;\n\n/**\n * Recorder\n * Simple Audio Recorder based on Web Audio API technology.\n *\n * This audio recorder tries to capture audio in WAV format\n * with some defaults that should work best.\n *\n * If this does not supply in your case, build your own recorder!\n */\nexport default class Recorder extends AudioContext {\n  /** @private */\n  audioFormat = null;\n\n  /** @private */\n  channels = null;\n\n  /** @private */\n  sampleRate = null;\n\n  /** @private */\n  sampleWidth = null;\n\n  /** @private */\n  stream = null;\n\n  mediaStreamSource = null;\n\n  constructor(options = {}) {\n    super();\n\n    const {\n      audioFormat = DEFAULT_AUDIO_FORMAT,\n      channels = DEFAULT_CHANNELS,\n      sampleRate = DEFAULT_SAMPLE_RATE,\n      sampleWidth = DEFAULT_SAMPLE_WIDTH,\n    } = options;\n\n    this.audioFormat = audioFormat;\n    this.channels = channels;\n    this.sampleRate = sampleRate;\n    this.sampleWidth = sampleWidth;\n  }\n\n  createStream() {\n    return navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {\n      this.stream = stream;\n      this.fireEvent('ready');\n    }).catch(({ name, message }) => {\n      this.error(`${name}: ${message}`);\n    });\n  }\n\n  startRecording() {\n    if (!this.stream) {\n      this.createStream().then(() => {\n        this.createAndConnect();\n      });\n    } else {\n      this.createAndConnect();\n    }\n  }\n\n  /**\n   * @private\n   */\n  createAndConnect() {\n    this.mediaStreamSource = this.audioContext.createMediaStreamSource(this.stream);\n    this.mediaStreamSource.connect(this.audioContext.destination);\n    this.fireEvent('recording');\n  }\n\n  stopRecording() {\n    this.mediaStreamSource.disconnect();\n    this.stream.getAudioTracks().forEach((track) => {\n      track.stop();\n    });\n    this.suspendAudioContext();\n    this.fireEvent('recorded');\n  }\n\n  getAudioSpecs() {\n    return {\n      audioFormat: this.audioFormat,\n      audioParameters: {\n        channels: this.channels,\n        frameRate: this.sampleRate,\n        sampleWidth: this.sampleWidth,\n      },\n    };\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/WebAudio/Recorder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 107,
    "kind": "variable",
    "name": "DEFAULT_AUDIO_FORMAT",
    "memberof": "src/WebAudio/Recorder.js",
    "static": true,
    "longname": "src/WebAudio/Recorder.js~DEFAULT_AUDIO_FORMAT",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/WebAudio/Recorder.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 108,
    "kind": "variable",
    "name": "DEFAULT_CHANNELS",
    "memberof": "src/WebAudio/Recorder.js",
    "static": true,
    "longname": "src/WebAudio/Recorder.js~DEFAULT_CHANNELS",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/WebAudio/Recorder.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 109,
    "kind": "variable",
    "name": "DEFAULT_SAMPLE_WIDTH",
    "memberof": "src/WebAudio/Recorder.js",
    "static": true,
    "longname": "src/WebAudio/Recorder.js~DEFAULT_SAMPLE_WIDTH",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/WebAudio/Recorder.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 110,
    "kind": "variable",
    "name": "DEFAULT_SAMPLE_RATE",
    "memberof": "src/WebAudio/Recorder.js",
    "static": true,
    "longname": "src/WebAudio/Recorder.js~DEFAULT_SAMPLE_RATE",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/WebAudio/Recorder.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 111,
    "kind": "class",
    "name": "Recorder",
    "memberof": "src/WebAudio/Recorder.js",
    "static": true,
    "longname": "src/WebAudio/Recorder.js~Recorder",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/WebAudio/Recorder.js",
    "importStyle": "Recorder",
    "description": "Recorder\nSimple Audio Recorder based on Web Audio API technology.\n\nThis audio recorder tries to capture audio in WAV format\nwith some defaults that should work best.\n\nIf this does not supply in your case, build your own recorder!",
    "lineNumber": 17,
    "interface": false,
    "extends": [
      "src/WebAudio/AudioContext.js~AudioContext"
    ]
  },
  {
    "__docId__": 112,
    "kind": "member",
    "name": "audioFormat",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#audioFormat",
    "access": "private",
    "description": null,
    "lineNumber": 19,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 113,
    "kind": "member",
    "name": "channels",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#channels",
    "access": "private",
    "description": null,
    "lineNumber": 22,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "member",
    "name": "sampleRate",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#sampleRate",
    "access": "private",
    "description": null,
    "lineNumber": 25,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 115,
    "kind": "member",
    "name": "sampleWidth",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#sampleWidth",
    "access": "private",
    "description": null,
    "lineNumber": 28,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "member",
    "name": "stream",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#stream",
    "access": "private",
    "description": null,
    "lineNumber": 31,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 117,
    "kind": "member",
    "name": "mediaStreamSource",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#mediaStreamSource",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 118,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "createStream",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#createStream",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 125,
    "kind": "method",
    "name": "startRecording",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#startRecording",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 126,
    "kind": "method",
    "name": "createAndConnect",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#createAndConnect",
    "access": "private",
    "description": "",
    "lineNumber": 73,
    "params": [],
    "return": null
  },
  {
    "__docId__": 128,
    "kind": "method",
    "name": "stopRecording",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#stopRecording",
    "access": "public",
    "description": null,
    "lineNumber": 79,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 129,
    "kind": "method",
    "name": "getAudioSpecs",
    "memberof": "src/WebAudio/Recorder.js~Recorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/WebAudio/Recorder.js~Recorder#getAudioSpecs",
    "access": "public",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "{\"audioFormat\": *, \"audioParameters\": *}"
      ]
    }
  },
  {
    "__docId__": 130,
    "kind": "file",
    "name": "src/api/auth/index.js",
    "content": "/**\n * This file contains a set of functions which makes authentication easier.\n *\n * @see {@link https://itslanguage.github.io/itslanguage-docs/api/oauth2/index.html}\n */\n\nimport { authorisedRequest, request, updateSettings } from '../communication';\n\n\n/**\n * Assemble the scope form the given individual pieces.\n *\n * The scope is used to identify what the authenticated is allowed to do. It can slo be used by\n * admin and tenant users to impersonate as a tenant, organisation or user.\n *\n * Keep in mind that in order to specify the user, the scope also needs to be specified.\n *\n * @see {@link https://itslanguage.github.io/itslanguage-docs/api/oauth2/index.html#impersonation}\n *\n * @param {string} [tenant] - The ID of the tenant which is requesting this scope.\n * @param {string} [organisation] - The ID of the organisation which is requesting this scope.\n * @param {string} [user] - The ID of the user which is requesting this scope.\n *\n * @throws {Error} - When no arguments are provided.\n *\n * @returns {string} - The assembled scope.\n */\nexport function assembleScope(tenant, organisation, user) {\n  if (!tenant && !organisation && !user) {\n    throw new Error('Arguments are required to assemble scope.');\n  }\n\n  let scope = `tenant/${tenant}`;\n\n  if (organisation) {\n    scope += `/organisation/${organisation}`;\n\n    if (user) {\n      scope += `/user/${user}`;\n    }\n  }\n\n  // The special admin user, no tenant and organisation provided\n  if (!tenant && !organisation && user) {\n    scope = `user/${user}`;\n  }\n\n  // The TENANT user, has no organisation\n  if (tenant && !organisation && user) {\n    scope += `/user/${user}`;\n  }\n\n  return scope;\n}\n\n/**\n * Impersonate some other tenant, user or organisation. The impersonation will be done by using\n * the authorisation token for the current user.\n *\n * On a successful impersonation, the settings are updated so every follow-up API requests is\n * authorized by the access_token required with this impersonation.\n *\n * As an admin or tenant user it is possible to do impersonation. This goes from top to down. So, a\n * tenant user can impersonate an organisation, or an user in an organisation. But an user can't\n * impersonate.\n *\n * @see {@link https://itslanguage.github.io/itslanguage-docs/api/oauth2/index.html#impersonation}\n *\n * @param {string} [scope] - The scope of the impersonation. Omitting this value will cause the API\n * to return a token for the current user.\n *\n * @returns {Promise} - A promise which will resolve if the authentication concluded successfully,\n * it'll reject in any other case. It resolves with the response body of the token request.\n */\nexport function impersonate(scope) {\n  const body = new URLSearchParams();\n\n  body.set('grant_type', 'client_credentials');\n\n  if (scope) {\n    body.set('scope', scope);\n  }\n\n  return authorisedRequest('POST', '/tokens', body)\n    .then((result) => {\n      updateSettings({ authorizationToken: result.access_token });\n      return result;\n    });\n}\n\n/**\n * Authenticate for the given credentials with the given scope.\n *\n * On a successful authentication, the settings are updated so every follow-up API requests is\n * authorized by the currently authenticated user.\n *\n * @param {string} username - The username to authenticate with.\n * @param {string} password - The password to authenticate with.\n * @param {string} [scope] - The scope of the authentication. Omitting this\n * value will cause the API to infer the scope.\n *\n * @returns {Promise} - A promise which will resolve if the authentication concluded successfully,\n * it'll reject in any other case. It resolves with the response body of the token request.\n */\nexport function authenticate(username, password, scope) {\n  const body = new URLSearchParams();\n\n  body.set('grant_type', 'password');\n  body.set('username', username);\n  body.set('password', password);\n\n  if (scope) {\n    body.set('scope', scope);\n  }\n\n  return request('POST', '/tokens', body)\n    .then((result) => {\n      updateSettings({ authorizationToken: result.access_token });\n      return result;\n    });\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/auth/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 131,
    "kind": "function",
    "name": "assembleScope",
    "memberof": "src/api/auth/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/auth/index.js~assembleScope",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/auth/index.js",
    "importStyle": "{assembleScope}",
    "description": "Assemble the scope form the given individual pieces.\n\nThe scope is used to identify what the authenticated is allowed to do. It can slo be used by\nadmin and tenant users to impersonate as a tenant, organisation or user.\n\nKeep in mind that in order to specify the user, the scope also needs to be specified.",
    "see": [
      "{@link https://itslanguage.github.io/itslanguage-docs/api/oauth2/index.html#impersonation}"
    ],
    "lineNumber": 28,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - The assembled scope."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "tenant",
        "description": "The ID of the tenant which is requesting this scope."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "organisation",
        "description": "The ID of the organisation which is requesting this scope."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "user",
        "description": "The ID of the user which is requesting this scope."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The assembled scope."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "When no arguments are provided."
      }
    ]
  },
  {
    "__docId__": 132,
    "kind": "function",
    "name": "impersonate",
    "memberof": "src/api/auth/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/auth/index.js~impersonate",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/auth/index.js",
    "importStyle": "{impersonate}",
    "description": "Impersonate some other tenant, user or organisation. The impersonation will be done by using\nthe authorisation token for the current user.\n\nOn a successful impersonation, the settings are updated so every follow-up API requests is\nauthorized by the access_token required with this impersonation.\n\nAs an admin or tenant user it is possible to do impersonation. This goes from top to down. So, a\ntenant user can impersonate an organisation, or an user in an organisation. But an user can't\nimpersonate.",
    "see": [
      "{@link https://itslanguage.github.io/itslanguage-docs/api/oauth2/index.html#impersonation}"
    ],
    "lineNumber": 75,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - A promise which will resolve if the authentication concluded successfully,\nit'll reject in any other case. It resolves with the response body of the token request."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "scope",
        "description": "The scope of the impersonation. Omitting this value will cause the API\nto return a token for the current user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise which will resolve if the authentication concluded successfully,\nit'll reject in any other case. It resolves with the response body of the token request."
    }
  },
  {
    "__docId__": 133,
    "kind": "function",
    "name": "authenticate",
    "memberof": "src/api/auth/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/auth/index.js~authenticate",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/auth/index.js",
    "importStyle": "{authenticate}",
    "description": "Authenticate for the given credentials with the given scope.\n\nOn a successful authentication, the settings are updated so every follow-up API requests is\nauthorized by the currently authenticated user.",
    "lineNumber": 105,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - A promise which will resolve if the authentication concluded successfully,\nit'll reject in any other case. It resolves with the response body of the token request."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": "The username to authenticate with."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "password",
        "description": "The password to authenticate with."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "scope",
        "description": "The scope of the authentication. Omitting this\nvalue will cause the API to infer the scope."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise which will resolve if the authentication concluded successfully,\nit'll reject in any other case. It resolves with the response body of the token request."
    }
  },
  {
    "__docId__": 134,
    "kind": "file",
    "name": "src/api/basicauth/index.js",
    "content": "/**\n * This file contains the readily available functions which interact with the ITSLanguage user API.\n * Users can have username/password based credentials (basicauth). These credentials can be managed\n * using the REST API. Only users with administrative powers can perform these calls.\n *\n * @see {@link https://itslanguage.github.io/itslanguage-docs/api/basicauths/index.html}\n */\n\nimport { authorisedRequest } from '../communication';\n\n/**\n * The URL for the basicAuth handler.\n * @type {string}\n */\nconst url = '/user/basicauths';\n\n/**\n * Create a basicAuth for the current user.\n * To create a basicAuth for another user, impersonate the user first.\n * A username must be unique in an organisation, but not across them.\n *\n * @param {string} basicAuth - The Id of the user to create or overwrite a profile for.\n * @param {string} [basicAuth.username] - The profile containing information about the user.\n * @param {string} [basicAuth.password ] - The groups this user is part of.\n *\n * @returns {Promise} - The basicauth creation promise.\n */\n// eslint-disable-next-line import/prefer-default-export\nexport function create(basicAuth) {\n  return authorisedRequest('POST', url, basicAuth);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/basicauth/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 135,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/basicauth/index.js",
    "static": true,
    "longname": "src/api/basicauth/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/basicauth/index.js",
    "importStyle": null,
    "description": "The URL for the basicAuth handler.",
    "lineNumber": 15,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 136,
    "kind": "function",
    "name": "create",
    "memberof": "src/api/basicauth/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/basicauth/index.js~create",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/basicauth/index.js",
    "importStyle": "{create}",
    "description": "Create a basicAuth for the current user.\nTo create a basicAuth for another user, impersonate the user first.\nA username must be unique in an organisation, but not across them.",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The basicauth creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "basicAuth",
        "description": "The Id of the user to create or overwrite a profile for."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "basicAuth.username",
        "description": "The profile containing information about the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "basicAuth.password",
        "description": "The groups this user is part of."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The basicauth creation promise."
    }
  },
  {
    "__docId__": 137,
    "kind": "file",
    "name": "src/api/broadcaster/index.js",
    "content": "/**\n * This module exposes the single event emitter. All events are sent through\n * this emitter. For usage; see the documentation of\n * [event-emitter][GitHub event-emitter].\n *\n * [GitHub event-emitter]: https://github.com/medikoo/event-emitter\n */\n\nimport ee from 'event-emitter';\n\n\n/**\n * The single event channel used throughout the ITSLanguage SDK.\n *\n * @type {event-emitter.EventEmitter}\n */\nconst broadcaster = ee();\n\n\nexport default broadcaster;\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/broadcaster/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 138,
    "kind": "variable",
    "name": "broadcaster",
    "memberof": "src/api/broadcaster/index.js",
    "static": true,
    "longname": "src/api/broadcaster/index.js~broadcaster",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/broadcaster/index.js",
    "importStyle": "broadcaster",
    "description": "The single event channel used throughout the ITSLanguage SDK.",
    "lineNumber": 17,
    "type": {
      "nullable": null,
      "types": [
        "event-emitter.EventEmitter"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 139,
    "kind": "file",
    "name": "src/api/categories/index.js",
    "content": "/**\n * This file contains the readily available functions which interact with the\n * ITSLanguage categories API.\n *\n * Categorize Speech Challenges or categories.\n *\n * @see {@link https://itslanguage.github.io/itslanguage-docs/api/categories/index.html}\n *\n */\n\nimport { authorisedRequest } from '../communication';\n\n/**\n * The URL for the category handler(s).\n * @type {string}\n */\nconst url = '/categories';\n\n\n/**\n * Create a new category.\n *\n * The most convenient way to pas a category to this create function is to make use of the FormData\n * object.\n *\n * @param {Object} category - The category to create.\n * @param {string} [category.id] - The category identifier. If none is given, one is generated.\n * @param {string} [category.parent] - Identifier of the parent category.\n * @param {string} [category.name] - A name for the category.\n * @param {string} [category.description] - A possible more verbose description about the category.\n * @param {string} [category.color] - A color, preferably in RGB format.\n * @param {blob} [category.image] - An image to show with the category.\n * @param {blob} [category.icon] - An icon to show with the category.\n * @param {string} [category.speechChallenges] - Speech Challenge identifiers categorized in the\n * category.\n *\n * @returns {Promise} - The category creation promise.\n */\nexport function create(category) {\n  return authorisedRequest('POST', url, category);\n}\n\n\n/**\n * Update one or more properties of an existing category.\n *\n * @param {string} id - The category identified.\n * @param {Object} properties - The properties of the category to update.\n * @param {string} [properties.parent] - Identifier of the parent category.\n * @param {string} [properties.name] - A name for the category.\n * @param {string} [properties.description] - A more verbose description about the category.\n * @param {string} [properties.color] - A color, preferably in RGB format.\n * @param {blob} [properties.image] - An image to show with the category.\n * @param {blob} [properties.icon] - An icon to show with the category.\n * @param {Array} [properties.speechChallenges] - An array of Speech Challenges identifiers\n * categorized in the category.\n *\n * @returns {Promise} - The category update promise.\n */\nexport function update(id, properties) {\n  return authorisedRequest('PUT', `${url}/${id}`, properties);\n}\n\n\n/**\n * Get a single category by its ID.\n *\n * @param {string} id - The ID of the desired category.\n *\n * @returns {Promise} - The promise for the category.\n */\nexport function getById(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get a all top level categories.\n * Top level categories are categories without a parent category.\n *\n * By default all categories are fetched though it is allowed to pass filters as a\n * `URLSearchParams` object.\n *\n * @param {URLSearchParams} [filters] - The filters to apply to the category list.\n *\n * @throws {Promise<string>} - If the given optional filters are not an instance of\n * `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the categories.\n */\nexport function getAll(filters) {\n  let urlWithFilters = url;\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject(new Error('The filters should be a `URLSearchParams` object.'));\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n\n/**\n * Get all categories that share the same parent.\n *\n * @param {string} id - The category identifier.\n *\n * @returns {Promise} - A promise and when fulfilled the requested categories.\n */\nexport function getAllWithParentId(id) {\n  return authorisedRequest('GET', `${url}/${id}/categories`);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/categories/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 140,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/categories/index.js",
    "static": true,
    "longname": "src/api/categories/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/categories/index.js",
    "importStyle": null,
    "description": "The URL for the category handler(s).",
    "lineNumber": 17,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 141,
    "kind": "function",
    "name": "create",
    "memberof": "src/api/categories/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/categories/index.js~create",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/categories/index.js",
    "importStyle": "{create}",
    "description": "Create a new category.\n\nThe most convenient way to pas a category to this create function is to make use of the FormData\nobject.",
    "lineNumber": 39,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The category creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "category",
        "description": "The category to create."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "category.id",
        "description": "The category identifier. If none is given, one is generated."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "category.parent",
        "description": "Identifier of the parent category."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "category.name",
        "description": "A name for the category."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "category.description",
        "description": "A possible more verbose description about the category."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "category.color",
        "description": "A color, preferably in RGB format."
      },
      {
        "nullable": null,
        "types": [
          "blob"
        ],
        "spread": false,
        "optional": true,
        "name": "category.image",
        "description": "An image to show with the category."
      },
      {
        "nullable": null,
        "types": [
          "blob"
        ],
        "spread": false,
        "optional": true,
        "name": "category.icon",
        "description": "An icon to show with the category."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "category.speechChallenges",
        "description": "Speech Challenge identifiers categorized in the\ncategory."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The category creation promise."
    }
  },
  {
    "__docId__": 142,
    "kind": "function",
    "name": "update",
    "memberof": "src/api/categories/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/categories/index.js~update",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/categories/index.js",
    "importStyle": "{update}",
    "description": "Update one or more properties of an existing category.",
    "lineNumber": 60,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The category update promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The category identified."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "properties",
        "description": "The properties of the category to update."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "properties.parent",
        "description": "Identifier of the parent category."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "properties.name",
        "description": "A name for the category."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "properties.description",
        "description": "A more verbose description about the category."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "properties.color",
        "description": "A color, preferably in RGB format."
      },
      {
        "nullable": null,
        "types": [
          "blob"
        ],
        "spread": false,
        "optional": true,
        "name": "properties.image",
        "description": "An image to show with the category."
      },
      {
        "nullable": null,
        "types": [
          "blob"
        ],
        "spread": false,
        "optional": true,
        "name": "properties.icon",
        "description": "An icon to show with the category."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "properties.speechChallenges",
        "description": "An array of Speech Challenges identifiers\ncategorized in the category."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The category update promise."
    }
  },
  {
    "__docId__": 143,
    "kind": "function",
    "name": "getById",
    "memberof": "src/api/categories/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/categories/index.js~getById",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/categories/index.js",
    "importStyle": "{getById}",
    "description": "Get a single category by its ID.",
    "lineNumber": 72,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the category."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired category."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the category."
    }
  },
  {
    "__docId__": 144,
    "kind": "function",
    "name": "getAll",
    "memberof": "src/api/categories/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/categories/index.js~getAll",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/categories/index.js",
    "importStyle": "{getAll}",
    "description": "Get a all top level categories.\nTop level categories are categories without a parent category.\n\nBy default all categories are fetched though it is allowed to pass filters as a\n`URLSearchParams` object.",
    "lineNumber": 91,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the categories."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the categories."
    },
    "throws": [
      {
        "types": [
          "Promise<string>"
        ],
        "description": "If the given optional filters are not an instance of\n`URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 145,
    "kind": "function",
    "name": "getAllWithParentId",
    "memberof": "src/api/categories/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/categories/index.js~getAllWithParentId",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/categories/index.js",
    "importStyle": "{getAllWithParentId}",
    "description": "Get all categories that share the same parent.",
    "lineNumber": 112,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - A promise and when fulfilled the requested categories."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The category identifier."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise and when fulfilled the requested categories."
    }
  },
  {
    "__docId__": 146,
    "kind": "file",
    "name": "src/api/challenges/choice/index.js",
    "content": "/**\n * This file contains the readily available functions which interact with the\n * ITSLanguage choice challenge API.\n */\n\nimport { authorisedRequest } from '../../communication';\n\n/**\n * The URL for the choice challenge handler(s).\n * @type {string}\n */\nconst url = '/challenges/choice';\n\n\n/**\n * Create a new choice challenge.\n *\n * @param {Object} challenge - The challenge to create.\n *\n * @returns {Promise} - The challenge creation promise.\n */\nexport function create(challenge) {\n  return authorisedRequest('POST', url, challenge);\n}\n\n\n/**\n * Get a single choice challenge by its ID.\n *\n * @param {string} id - The ID of the desired choice challenge.\n *\n * @returns {Promise} - The promise for the choice challenge.\n */\nexport function getById(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get a all choice challenges.\n *\n * By default all choice challenges are fetched though it is allowed to pass filters as a\n * `URLSearchParams` object.\n *\n * @param {URLSearchParams} [filters] - The filters to apply to the category list.\n *\n * @throws {Promise<string>} - If the given optional filters are not an instance of\n * `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the choice challenges.\n */\nexport function getAll(filters) {\n  let urlWithFilters = url;\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject(new Error('The filters should be a `URLSearchParams` object.'));\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/challenges/choice/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 147,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/challenges/choice/index.js",
    "static": true,
    "longname": "src/api/challenges/choice/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/challenges/choice/index.js",
    "importStyle": null,
    "description": "The URL for the choice challenge handler(s).",
    "lineNumber": 12,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 148,
    "kind": "function",
    "name": "create",
    "memberof": "src/api/challenges/choice/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/index.js~create",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/choice/index.js",
    "importStyle": "{create}",
    "description": "Create a new choice challenge.",
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The challenge creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The challenge to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The challenge creation promise."
    }
  },
  {
    "__docId__": 149,
    "kind": "function",
    "name": "getById",
    "memberof": "src/api/challenges/choice/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/index.js~getById",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/choice/index.js",
    "importStyle": "{getById}",
    "description": "Get a single choice challenge by its ID.",
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the choice challenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired choice challenge."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the choice challenge."
    }
  },
  {
    "__docId__": 150,
    "kind": "function",
    "name": "getAll",
    "memberof": "src/api/challenges/choice/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/index.js~getAll",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/choice/index.js",
    "importStyle": "{getAll}",
    "description": "Get a all choice challenges.\n\nBy default all choice challenges are fetched though it is allowed to pass filters as a\n`URLSearchParams` object.",
    "lineNumber": 52,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the choice challenges."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the choice challenges."
    },
    "throws": [
      {
        "types": [
          "Promise<string>"
        ],
        "description": "If the given optional filters are not an instance of\n`URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 151,
    "kind": "file",
    "name": "src/api/challenges/choice/recognition.js",
    "content": "/**\n * This file contains the readily available functions which interact with the\n * ITSLanguage choice recognition API.\n *\n * Speech recognitions can be stored and retrieved for user submitted audio using the ITSLanguage\n * Speech API. The actual recognitions are performed by the ITSLanguage websocket server.\n *\n * For streaming, note that this is one of the \"nested\" or \"composite\" APIs; You can only obtain the\n * data if you provide a reference to the challenge for which you want a recording.\n */\n\nimport {\n  registerStreamForRecorder,\n  waitForUserMediaApproval,\n} from '../../utils/audio-over-socket';\nimport { authorisedRequest } from '../../communication';\nimport { makeWebsocketCall } from '../../communication/websocket';\n\n/**\n * The URL for the choice recognition challenge handler(s).\n *\n * @param challengeId\n * @returns {string}\n */\nconst url = challengeId => `/challenges/choice/${challengeId}/recognitions`;\n\n\n/**\n * Submit an audio fragment for recognition. The recognition is created for the current\n * authenticated user.\n *\n * @see https://itslanguage.github.io/itslanguage-docs/api/recognitions/index.html#create-a-choice-recognition\n * @param {string} challengeId - The ID of the challenge to relate the recognition to.\n * @param {Blob} audio - The actual audio.\n * @param {string} recognised - The recognised string.\n * @param {string} [recognitionId=null] - Unique identifier for the recognition. If none is given,\n * one is generated.\n * @returns {Promise} - The created recognition with an url to download the audio if needed.\n */\nexport function create(challengeId, audio, recognised, recognitionId = null) {\n  const recognition = {\n    audio,\n    recognised,\n  };\n\n  if (recognitionId) {\n    recognition.id = recognitionId;\n  }\n\n  return authorisedRequest(\n    'POST',\n    `${url(challengeId)}`,\n    recognition,\n  );\n}\n\n\n/**\n * Get a single ChoiceRecognition by its ID.\n *\n * @see https://itslanguage.github.io/itslanguage-docs/api/recognitions/index.html#get-a-single-choice-recognition\n * @param {string} challengeId - ID of the Choice Challenge to get all the recognitions for.\n * @param {string} id - ID of the choice recognition to get.\n * @returns {Promise} - Promise with the Choice Recognition as result if successful.\n */\nexport function getById(challengeId, id) {\n  return authorisedRequest('GET', `${url(challengeId)}/${id}`);\n}\n\n\n/**\n * Get all Choice Recognitions for a specific Choice Challenge.\n *\n * @see https://itslanguage.github.io/itslanguage-docs/api/recognitions/index.html#list-choice-recognitions\n * @param {string} challengeId - ID of the Choice Challenge to get all the recognitions for.\n * @returns {Promise} - Promise with the Choice Recognitions as result if successful.\n */\nexport function getAll(challengeId) {\n  return authorisedRequest('GET', `${url(challengeId)}`);\n}\n\n\n/**\n * This is the starting point for a choice recognition. A unique recognition id is generated,\n * which serves a leading role in the recognition. Each other call requires the recognition id\n * as a parameter.\n *\n * If other RPCs are called without this RPC being called first, the error\n * `nl.itslanguage.session_not_initialised` will be returned.\n *\n * @see https://itslanguage.github.io/itslanguage-docs/websocket/choice_recognitions/index.html#initialising-a-choice-recognition\n * @returns {Promise} - Returns a promise. When successfully the ID of the recognition is returned.\n */\nexport function prepare() {\n  return makeWebsocketCall('choice.init_recognition');\n}\n\n\n/**\n * Before performing the recognition, a WFST needs to be prepared for the challenge. When the RPC is\n * called, the challenge is initialised asynchronously. When the challenge is to be used, the server\n * automatically waits for the challenge initialisation to finish. If the initialisation results in\n * an error, the error is relayed to the client.\n *\n * @see https://itslanguage.github.io/itslanguage-docs/websocket/choice_recognitions/index.html#initialise-choice-challenge\n * @param {string} recognitionId - The ID of the recognition to prepare the challenge for.\n * @param {string} challengeId - The ID of the challenge to prepare.\n * @returns {Promise} - If succesful the promise returns nothing. On error, there will be an error.\n */\nexport function prepareChallenge(recognitionId, challengeId) {\n  return makeWebsocketCall('choice.init_challenge', { args: [recognitionId, challengeId] });\n}\n\n\n/**\n * Based on a recognitionId and a recorder register a RPC call that will be used to send the audio\n * across the line. The actual registration will not be done here, but we send the RPC that the\n * backend needs to call to the 'nl.itslanguage.choice.recognise' function.\n *\n * @param {string} recognitionId - The ID of the recognition to send audio for.\n * @param {Recorder} recorder - Audio recorder instance.\n * @returns {Promise} - When all good, the result will have the actual recognition.\n */\nexport function recogniseAudioStream(recognitionId, recorder) {\n  // Generate a somewhat unique RPC name\n  const rpcNameToRegister = `choice.stream.${Math.floor(Date.now() / 1000)}`;\n  return registerStreamForRecorder(recorder, rpcNameToRegister)\n    // We don't use rpcNameToRegister here because it lacks some namespacing info. The\n    // registration.procedure does have the needed information.\n    .then(registration => makeWebsocketCall('choice.recognise', { args: [recognitionId, registration.procedure] }));\n}\n\n\n/**\n * Easy function to do a recognition in one go. This is the \"dance of the RPC's\" that needs to be\n * done in order to get correct feedback from the backend.\n *\n * @param {string} challengeId - The ID of the challenge to take the recognition for.\n * @param {Recorder} recorder - Audio recorder instance.\n * @returns {Promise<*>} - If all good it returns the actual recognition. If not, any error can be\n * expected to be returned.\n */\nexport function recognise(challengeId, recorder) {\n  let recognitionId;\n  return prepare()\n    .then((rId) => {\n      recognitionId = rId;\n      return waitForUserMediaApproval(recognitionId, recorder);\n    })\n    .then(() => prepareChallenge(recognitionId, challengeId))\n    .then(() => recogniseAudioStream(recognitionId, recorder).then(result => result));\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/challenges/choice/recognition.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 152,
    "kind": "function",
    "name": "url",
    "memberof": "src/api/challenges/choice/recognition.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/recognition.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/challenges/choice/recognition.js",
    "importStyle": null,
    "description": "The URL for the choice recognition challenge handler(s).",
    "lineNumber": 25,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 153,
    "kind": "function",
    "name": "create",
    "memberof": "src/api/challenges/choice/recognition.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/recognition.js~create",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/choice/recognition.js",
    "importStyle": "{create}",
    "description": "Submit an audio fragment for recognition. The recognition is created for the current\nauthenticated user.",
    "see": [
      "https://itslanguage.github.io/itslanguage-docs/api/recognitions/index.html#create-a-choice-recognition"
    ],
    "lineNumber": 40,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The created recognition with an url to download the audio if needed."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The ID of the challenge to relate the recognition to."
      },
      {
        "nullable": null,
        "types": [
          "Blob"
        ],
        "spread": false,
        "optional": false,
        "name": "audio",
        "description": "The actual audio."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "recognised",
        "description": "The recognised string."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "recognitionId",
        "description": "Unique identifier for the recognition. If none is given,\none is generated."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The created recognition with an url to download the audio if needed."
    }
  },
  {
    "__docId__": 154,
    "kind": "function",
    "name": "getById",
    "memberof": "src/api/challenges/choice/recognition.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/recognition.js~getById",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/choice/recognition.js",
    "importStyle": "{getById}",
    "description": "Get a single ChoiceRecognition by its ID.",
    "see": [
      "https://itslanguage.github.io/itslanguage-docs/api/recognitions/index.html#get-a-single-choice-recognition"
    ],
    "lineNumber": 66,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - Promise with the Choice Recognition as result if successful."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "ID of the Choice Challenge to get all the recognitions for."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "ID of the choice recognition to get."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise with the Choice Recognition as result if successful."
    }
  },
  {
    "__docId__": 155,
    "kind": "function",
    "name": "getAll",
    "memberof": "src/api/challenges/choice/recognition.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/recognition.js~getAll",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/choice/recognition.js",
    "importStyle": "{getAll}",
    "description": "Get all Choice Recognitions for a specific Choice Challenge.",
    "see": [
      "https://itslanguage.github.io/itslanguage-docs/api/recognitions/index.html#list-choice-recognitions"
    ],
    "lineNumber": 78,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - Promise with the Choice Recognitions as result if successful."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "ID of the Choice Challenge to get all the recognitions for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Promise with the Choice Recognitions as result if successful."
    }
  },
  {
    "__docId__": 156,
    "kind": "function",
    "name": "prepare",
    "memberof": "src/api/challenges/choice/recognition.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/recognition.js~prepare",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/choice/recognition.js",
    "importStyle": "{prepare}",
    "description": "This is the starting point for a choice recognition. A unique recognition id is generated,\nwhich serves a leading role in the recognition. Each other call requires the recognition id\nas a parameter.\n\nIf other RPCs are called without this RPC being called first, the error\n`nl.itslanguage.session_not_initialised` will be returned.",
    "see": [
      "https://itslanguage.github.io/itslanguage-docs/websocket/choice_recognitions/index.html#initialising-a-choice-recognition"
    ],
    "lineNumber": 94,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - Returns a promise. When successfully the ID of the recognition is returned."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Returns a promise. When successfully the ID of the recognition is returned."
    },
    "params": []
  },
  {
    "__docId__": 157,
    "kind": "function",
    "name": "prepareChallenge",
    "memberof": "src/api/challenges/choice/recognition.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/recognition.js~prepareChallenge",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/choice/recognition.js",
    "importStyle": "{prepareChallenge}",
    "description": "Before performing the recognition, a WFST needs to be prepared for the challenge. When the RPC is\ncalled, the challenge is initialised asynchronously. When the challenge is to be used, the server\nautomatically waits for the challenge initialisation to finish. If the initialisation results in\nan error, the error is relayed to the client.",
    "see": [
      "https://itslanguage.github.io/itslanguage-docs/websocket/choice_recognitions/index.html#initialise-choice-challenge"
    ],
    "lineNumber": 110,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - If succesful the promise returns nothing. On error, there will be an error."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "recognitionId",
        "description": "The ID of the recognition to prepare the challenge for."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The ID of the challenge to prepare."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "If succesful the promise returns nothing. On error, there will be an error."
    }
  },
  {
    "__docId__": 158,
    "kind": "function",
    "name": "recogniseAudioStream",
    "memberof": "src/api/challenges/choice/recognition.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/recognition.js~recogniseAudioStream",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/choice/recognition.js",
    "importStyle": "{recogniseAudioStream}",
    "description": "Based on a recognitionId and a recorder register a RPC call that will be used to send the audio\nacross the line. The actual registration will not be done here, but we send the RPC that the\nbackend needs to call to the 'nl.itslanguage.choice.recognise' function.",
    "lineNumber": 124,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - When all good, the result will have the actual recognition."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "recognitionId",
        "description": "The ID of the recognition to send audio for."
      },
      {
        "nullable": null,
        "types": [
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "Audio recorder instance."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "When all good, the result will have the actual recognition."
    }
  },
  {
    "__docId__": 159,
    "kind": "function",
    "name": "recognise",
    "memberof": "src/api/challenges/choice/recognition.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/choice/recognition.js~recognise",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/choice/recognition.js",
    "importStyle": "{recognise}",
    "description": "Easy function to do a recognition in one go. This is the \"dance of the RPC's\" that needs to be\ndone in order to get correct feedback from the backend.",
    "lineNumber": 143,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<*>} - If all good it returns the actual recognition. If not, any error can be\nexpected to be returned."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The ID of the challenge to take the recognition for."
      },
      {
        "nullable": null,
        "types": [
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "Audio recorder instance."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "If all good it returns the actual recognition. If not, any error can be\nexpected to be returned."
    }
  },
  {
    "__docId__": 160,
    "kind": "file",
    "name": "src/api/challenges/feedback/index.js",
    "content": "/**\n * This file contains the functions that are needed to interact with\n * the ITSLanguage Feedback API.\n */\n\nimport { authorisedRequest } from '../../communication';\n\n/**\n * The URL for the feedback challenge handler(s).\n * @type {string}\n */\nconst url = '/feedback';\n\n\n/**\n * Create new feedback.\n *\n * @param {Object} feedback - The feedback to create.\n *\n * @returns {Promise} - The feedback creation promise.\n */\nexport function create(feedback) {\n  return authorisedRequest('POST', url, feedback);\n}\n\n\n/**\n * Get a single feedback challenge by its ID.\n * Feedback can only be get by the owning user or by a user with the TEACHER role.\n *\n * @see https://itslanguage.github.io/itslanguage-docs/api/feedback/index.html#get-feedback-by-id\n *\n * @param {string} id - The ID of the desired feedback challenge to get.\n *\n * @returns {Promise} - The promise for the feedback challenge.\n */\nexport function getById(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get all feedback. It will only return feedback that the user may see.\n * Feedback can only be get by the owning user or by a user with the TEACHER role.\n *\n * @returns {Promise} - The promise for the feedback challenges.\n */\nexport function getAll() {\n  return authorisedRequest('GET', url);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/challenges/feedback/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 161,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/challenges/feedback/index.js",
    "static": true,
    "longname": "src/api/challenges/feedback/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/challenges/feedback/index.js",
    "importStyle": null,
    "description": "The URL for the feedback challenge handler(s).",
    "lineNumber": 12,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 162,
    "kind": "function",
    "name": "create",
    "memberof": "src/api/challenges/feedback/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/feedback/index.js~create",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/feedback/index.js",
    "importStyle": "{create}",
    "description": "Create new feedback.",
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The feedback creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "feedback",
        "description": "The feedback to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The feedback creation promise."
    }
  },
  {
    "__docId__": 163,
    "kind": "function",
    "name": "getById",
    "memberof": "src/api/challenges/feedback/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/feedback/index.js~getById",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/feedback/index.js",
    "importStyle": "{getById}",
    "description": "Get a single feedback challenge by its ID.\nFeedback can only be get by the owning user or by a user with the TEACHER role.",
    "see": [
      "https://itslanguage.github.io/itslanguage-docs/api/feedback/index.html#get-feedback-by-id"
    ],
    "lineNumber": 37,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the feedback challenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired feedback challenge to get."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the feedback challenge."
    }
  },
  {
    "__docId__": 164,
    "kind": "function",
    "name": "getAll",
    "memberof": "src/api/challenges/feedback/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/feedback/index.js~getAll",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/feedback/index.js",
    "importStyle": "{getAll}",
    "description": "Get all feedback. It will only return feedback that the user may see.\nFeedback can only be get by the owning user or by a user with the TEACHER role.",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the feedback challenges."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the feedback challenges."
    },
    "params": []
  },
  {
    "__docId__": 165,
    "kind": "file",
    "name": "src/api/challenges/feedback/speech.js",
    "content": "/**\n * This file contains the functions that are needed to interact with the ITSLanguage Speech\n * Feedback API.\n *\n * It's possible to get feedback while recording. After every sentence feedback is provided\n * indicating whether or not the sentence was read well. This will be done through the\n * ITSLanguage WebSocket Server.\n *\n * The general approach for getting real-time feedback is:\n *  - Prepare the speech feedback\n *  - Register audio procedure for streaming\n *  - Start listening for audio\n *\n *  To read up on the Speech feedback:\n *  @see https://itslanguage.github.io/itslanguage-docs/websocket/feedback/index.html\n *\n *  To read more on Speech Challenges:\n *  @see https://itslanguage.github.io/itslanguage-docs/api/speech_challenges/index.html\n */\n\nimport {\n  registerStreamForRecorder,\n  waitForUserMediaApproval,\n} from '../../utils/audio-over-socket';\nimport { makeWebsocketCall } from '../../communication/websocket';\n\n/**\n * Prepare a new Speech Feedback.\n * Should be called upon each new speech feedback.\n * The backend will generate an unique ID for the feedback and prepare a speech challenge.\n *\n * @param {string} challengeId - The ID of the challenge to prepare.\n * @returns {Promise} - The ID of the Speech Feedback.\n */\nexport function prepare(challengeId) {\n  return makeWebsocketCall('feedback.prepare', { args: [challengeId] });\n}\n\n/**\n * In order to receive feedback the server needs to listen for audio on a registered audio rpc.\n * While listening the server will reply using progressive results. The server will stop listening\n * when the audio rpc returns.\n *\n * If you call this function the SDK will register an RPC method to the realm on which audio will be\n * streamed to the backend.\n *\n * @param {string} feedbackId - The Id of the Feedback Challenge.\n * @param {Function} progressCb - A callback which will be used to receive progress on.\n * @param {Recorder} recorder - Audio recorder instance.\n * @returns {Promise} - After each sentence there will be real-time feedback on that sentence. This\n * feedback will be given through the progressiveResultsCb function. When the rpc is done, the\n * promise will return an recording with the appropriate feedback per sentence.\n */\nexport function listenAndReply(feedbackId, progressCb, recorder) {\n  // Generate a somewhat unique RPC name\n  const rpcNameToRegister = `feedback.stream.${Math.floor(Date.now() / 1000)}`;\n\n  // Below we use registration.procedure instead of rpcNameToRegister. This is because the later\n  // lacks some namespace information that we do need.\n  return registerStreamForRecorder(recorder, rpcNameToRegister)\n    .then(registration => makeWebsocketCall(\n      'feedback.listen_and_reply',\n      {\n        args: [feedbackId, registration.procedure],\n        progressCb: progressCb.bind(null, feedbackId),\n      },\n    ));\n}\n\n/**\n * Feedback can be paused. This will stop the backend from processing the audio stream and returning\n * feedback.\n *\n * Important note: Pausing the feedback will not stop the feedback. Also make sure to stop sending\n * data from the recorder to the backend.\n *\n * @param {string} feedbackId - The ID of the feedback to pause.\n * @returns {Promise} - An error if something went wrong.\n */\nexport function pause(feedbackId) {\n  return makeWebsocketCall('feedback.pause', { args: [feedbackId] });\n}\n\n/**\n * A paused feedback can be resumed at a sentence in the challenge. If not provided, it will resume\n * at the first sentence.\n *\n * @param {string} feedbackId - The ID of the feedback to resume.\n * @param {string} sentenceId - The ID of the sentence to resume feedback from.\n * @returns {Promise} - An error if something went wrong.\n */\nexport function resume(feedbackId, sentenceId = 0) {\n  return makeWebsocketCall('feedback.resume', { args: [feedbackId, sentenceId] });\n}\n\n/**\n * Function for convenience. Using this function calls the corresponding functions so that the\n * required backend flow is backed up.\n *\n * It will call the following functions (and more important, in the correct order):\n *  - {@link prepare}.\n *  - {@link waitForUserMediaApproval}.\n *  - {@link listenAndReply}.\n *\n * @param {string} challengeId - The Id of the Challenge to get feedback on.\n * @param {Function} progressiveResultsCb - A callback which will be used to receive progress on.\n * @param {Recorder} recorder - Audio recorder instance.\n * @returns {Promise} - After each sentence there will be real-time feedback on that sentence. This\n * feedback will be given through the progressiveResultsCb function. When the rpc is done, the\n * promise will return an recording with the appropriate feedback per sentence.\n */\nexport function feedback(challengeId, progressiveResultsCb, recorder) {\n  return prepare(challengeId)\n    .then(feedbackId => waitForUserMediaApproval(feedbackId, recorder))\n    .then(feedbackId => listenAndReply(feedbackId, progressiveResultsCb, recorder));\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/challenges/feedback/speech.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 166,
    "kind": "function",
    "name": "prepare",
    "memberof": "src/api/challenges/feedback/speech.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/feedback/speech.js~prepare",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/feedback/speech.js",
    "importStyle": "{prepare}",
    "description": "Prepare a new Speech Feedback.\nShould be called upon each new speech feedback.\nThe backend will generate an unique ID for the feedback and prepare a speech challenge.",
    "lineNumber": 35,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The ID of the Speech Feedback."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The ID of the challenge to prepare."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The ID of the Speech Feedback."
    }
  },
  {
    "__docId__": 167,
    "kind": "function",
    "name": "listenAndReply",
    "memberof": "src/api/challenges/feedback/speech.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/feedback/speech.js~listenAndReply",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/feedback/speech.js",
    "importStyle": "{listenAndReply}",
    "description": "In order to receive feedback the server needs to listen for audio on a registered audio rpc.\nWhile listening the server will reply using progressive results. The server will stop listening\nwhen the audio rpc returns.\n\nIf you call this function the SDK will register an RPC method to the realm on which audio will be\nstreamed to the backend.",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - After each sentence there will be real-time feedback on that sentence. This\nfeedback will be given through the progressiveResultsCb function. When the rpc is done, the\npromise will return an recording with the appropriate feedback per sentence."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "feedbackId",
        "description": "The Id of the Feedback Challenge."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "progressCb",
        "description": "A callback which will be used to receive progress on."
      },
      {
        "nullable": null,
        "types": [
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "Audio recorder instance."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "After each sentence there will be real-time feedback on that sentence. This\nfeedback will be given through the progressiveResultsCb function. When the rpc is done, the\npromise will return an recording with the appropriate feedback per sentence."
    }
  },
  {
    "__docId__": 168,
    "kind": "function",
    "name": "pause",
    "memberof": "src/api/challenges/feedback/speech.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/feedback/speech.js~pause",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/feedback/speech.js",
    "importStyle": "{pause}",
    "description": "Feedback can be paused. This will stop the backend from processing the audio stream and returning\nfeedback.\n\nImportant note: Pausing the feedback will not stop the feedback. Also make sure to stop sending\ndata from the recorder to the backend.",
    "lineNumber": 80,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - An error if something went wrong."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "feedbackId",
        "description": "The ID of the feedback to pause."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "An error if something went wrong."
    }
  },
  {
    "__docId__": 169,
    "kind": "function",
    "name": "resume",
    "memberof": "src/api/challenges/feedback/speech.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/feedback/speech.js~resume",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/feedback/speech.js",
    "importStyle": "{resume}",
    "description": "A paused feedback can be resumed at a sentence in the challenge. If not provided, it will resume\nat the first sentence.",
    "lineNumber": 92,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - An error if something went wrong."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "feedbackId",
        "description": "The ID of the feedback to resume."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "sentenceId",
        "description": "The ID of the sentence to resume feedback from."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "An error if something went wrong."
    }
  },
  {
    "__docId__": 170,
    "kind": "function",
    "name": "feedback",
    "memberof": "src/api/challenges/feedback/speech.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/feedback/speech.js~feedback",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/feedback/speech.js",
    "importStyle": "{feedback}",
    "description": "Function for convenience. Using this function calls the corresponding functions so that the\nrequired backend flow is backed up.\n\nIt will call the following functions (and more important, in the correct order):\n - {@link prepare}.\n - {@link waitForUserMediaApproval}.\n - {@link listenAndReply}.",
    "lineNumber": 112,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - After each sentence there will be real-time feedback on that sentence. This\nfeedback will be given through the progressiveResultsCb function. When the rpc is done, the\npromise will return an recording with the appropriate feedback per sentence."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The Id of the Challenge to get feedback on."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "progressiveResultsCb",
        "description": "A callback which will be used to receive progress on."
      },
      {
        "nullable": null,
        "types": [
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "Audio recorder instance."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "After each sentence there will be real-time feedback on that sentence. This\nfeedback will be given through the progressiveResultsCb function. When the rpc is done, the\npromise will return an recording with the appropriate feedback per sentence."
    }
  },
  {
    "__docId__": 171,
    "kind": "file",
    "name": "src/api/challenges/index.js",
    "content": "import * as choiceApi from './choice';\nimport * as recognition from './choice/recognition';\nimport * as feedbackApi from './feedback';\nimport * as speechFeedback from './feedback/speech';\nimport * as pronunciationApi from './pronunciation';\nimport * as analysis from './pronunciation/analysis';\nimport * as speechApi from './speech';\nimport * as recording from './speech/recordings';\n\n\n/**\n * Interface to the Choice Challenge API (both REST and streaming).\n *\n * @type {{\n *   create?,\n *   getById?,\n *   getAll?,\n *   recognition: {\n *     create?,\n *     getAll?,\n *     prepare?,\n *     prepareChallenge?,\n *     getById?,\n *     recogniseAudioStream?,\n *     recognise?\n *   }\n * }}\n */\nexport const choice = {\n  ...choiceApi,\n  recognition,\n};\n\n/**\n * Interface to the Feedback API (both REST and streaming).\n *\n * @type {{\n *   create?,\n *   getById?,\n *   getAll?,\n *   prepare?,\n *   resume?,\n *   listenAndReply?,\n *   feedback?,\n *   pause?\n * }}\n */\nexport const feedback = {\n  ...feedbackApi,\n  ...speechFeedback,\n};\n\n/**\n * Interface to the Pronunciation Challenge API (both REST and streaming).\n *\n * @type {{\n *   create?,\n *   getAll?,\n *   getById?,\n *   deleteChallenge?,\n *   analysis: {\n *     prepare?,\n *     alignChallenge?,\n *     prepareChallenge?,\n *     getById?,\n *     endStreamAudio?,\n *     streamAudio?,\n *     prepareAudio?\n *   }\n * }}\n */\nexport const pronunciation = {\n  ...pronunciationApi,\n  analysis,\n};\n\n/**\n * Interface to the Speech Challenge API (both REST and streaming).\n *\n * @type {{\n *   create?,\n *   getById?,\n *   getAll?,\n *   recording: {\n *     getAll?,\n *     getById?,\n *     record?\n *   }\n * }}\n */\nexport const speech = {\n  ...speechApi,\n  recording,\n};\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/challenges/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 172,
    "kind": "variable",
    "name": "choice",
    "memberof": "src/api/challenges/index.js",
    "static": true,
    "longname": "src/api/challenges/index.js~choice",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/index.js",
    "importStyle": "{choice}",
    "description": "Interface to the Choice Challenge API (both REST and streaming).",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "{\n  create?,\n  getById?,\n  getAll?,\n  recognition: {\n    create?,\n    getAll?,\n    prepare?,\n    prepareChallenge?,\n    getById?,\n    recogniseAudioStream?,\n    recognise?\n  "
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 173,
    "kind": "variable",
    "name": "feedback",
    "memberof": "src/api/challenges/index.js",
    "static": true,
    "longname": "src/api/challenges/index.js~feedback",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/index.js",
    "importStyle": "{feedback}",
    "description": "Interface to the Feedback API (both REST and streaming).",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "{\n  create?,\n  getById?,\n  getAll?,\n  prepare?,\n  resume?,\n  listenAndReply?,\n  feedback?,\n  pause?\n}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 174,
    "kind": "variable",
    "name": "pronunciation",
    "memberof": "src/api/challenges/index.js",
    "static": true,
    "longname": "src/api/challenges/index.js~pronunciation",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/index.js",
    "importStyle": "{pronunciation}",
    "description": "Interface to the Pronunciation Challenge API (both REST and streaming).",
    "lineNumber": 72,
    "type": {
      "nullable": null,
      "types": [
        "{\n  create?,\n  getAll?,\n  getById?,\n  deleteChallenge?,\n  analysis: {\n    prepare?,\n    alignChallenge?,\n    prepareChallenge?,\n    getById?,\n    endStreamAudio?,\n    streamAudio?,\n    prepareAudio?\n  "
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 175,
    "kind": "variable",
    "name": "speech",
    "memberof": "src/api/challenges/index.js",
    "static": true,
    "longname": "src/api/challenges/index.js~speech",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/index.js",
    "importStyle": "{speech}",
    "description": "Interface to the Speech Challenge API (both REST and streaming).",
    "lineNumber": 91,
    "type": {
      "nullable": null,
      "types": [
        "{\n  create?,\n  getById?,\n  getAll?,\n  recording: {\n    getAll?,\n    getById?,\n    record?\n  "
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 176,
    "kind": "file",
    "name": "src/api/challenges/pronunciation/analysis.js",
    "content": "/**\n * This file contains the readily available functions which interact with the ITSLanguage\n * pronunciation analysis API.\n *\n * Note that this is one of the \"nested\" or \"composite\" APIs; You can only obtain the data if you\n * provide a reference to the challenge for which you want a recording.\n */\n\nimport {\n  encodeAndSendAudioOnDataAvailable,\n  prepareServerForAudio,\n} from '../../utils/audio-over-socket';\nimport { authorisedRequest } from '../../communication';\nimport { makeWebsocketCall } from '../../communication/websocket';\n\n/**\n * The URL for the Pronunciation Analysis handler(s).\n *\n * @param challenge\n * @returns {string}\n */\nconst url = challenge => `/challenges/pronunciation/${challenge}/analyses`;\n\n/**\n * Ask the backend for a Pronunciation Analysis.\n *\n * @param {string} challengeId - The ID of the corresponding challenge.\n * @param {string} analysisId - The ID of the analysis you want result for.\n * @returns {Promise<Object>} - The Pronunciation Analysis.\n */\nexport function getById(challengeId, analysisId) {\n  return authorisedRequest('GET', `${url(challengeId)}/${analysisId}`);\n}\n\n/**\n * Create a new analysis and return the ID.\n *\n * @returns {Promise|Promise<*>} - The result will hold the ID for the analysis.\n */\nexport function prepare() {\n  return makeWebsocketCall('pronunciation.init_analysis');\n}\n\n/**\n * Prepare the backend by telling it which challenge it can expect by a new analysis.\n *\n * @param {string} analysisId - The ID of the analysis to attache the challenge to.\n * @param {string} challengeId - The ID of the challenge that belongs to a specific analysis.\n * @returns {Promise<*>} - Promise with the result of the init_challenge call.\n */\nexport function prepareChallenge(analysisId, challengeId) {\n  return makeWebsocketCall('pronunciation.init_challenge', { args: [analysisId, challengeId] });\n}\n\n/**\n * A Pronunciation Challenge could hold an alignment already. If not so this function will instruct\n * the backend to create the alignment and return it to the client.\n *\n * @param {string} analysisId - The ID of the analysis to create the alignment for.\n * @returns {Promise<*>} - The alignment.\n */\nexport function alignChallenge(analysisId) {\n  return makeWebsocketCall('pronunciation.alignment', { args: [analysisId] });\n}\n\n/**\n * Prepare the backend for our audio.\n *\n * @param {string} analyseId - The Analysis that belongs to the audio.\n * @param {Recorder} recorder - The recorder to get specs from.\n * @returns {Promise} - Result of preparing the audio.\n */\nexport function prepareAudio(analyseId, recorder) {\n  return prepareServerForAudio(analyseId, recorder, 'pronunciation.init_audio');\n}\n\n/**\n * Us the provided recorder to stream/send the recorded audio to the backend.\n *\n * @param {string} analyseId - The ID of the analysis we're receiving audio for.\n * @param {Recorder} recorder - Instance of an Recorder.\n * @returns {Promise} - Stream result.\n */\nexport function streamAudio(analyseId, recorder) {\n  return encodeAndSendAudioOnDataAvailable(analyseId, recorder, 'pronunciation.write');\n}\n\n/**\n * Finishing the recording means we're ready to analyse! Smartest man in the entire universe.\n * We also accept a special callback that can be used to receive progress on.\n *\n * @param {string} analyseId - The ID of the Analysis to analyse on.\n * @param {Function} [progressCb] - A callback which will be used to receive progress on.\n * @returns {Promise<*>} - The result will return the analysis.\n */\nexport function endStreamAudio(analyseId, progressCb) {\n  return makeWebsocketCall('pronunciation.analyse', { args: [analyseId], progressCb });\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/challenges/pronunciation/analysis.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 177,
    "kind": "function",
    "name": "url",
    "memberof": "src/api/challenges/pronunciation/analysis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/analysis.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/challenges/pronunciation/analysis.js",
    "importStyle": null,
    "description": "The URL for the Pronunciation Analysis handler(s).",
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 178,
    "kind": "function",
    "name": "getById",
    "memberof": "src/api/challenges/pronunciation/analysis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/analysis.js~getById",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/pronunciation/analysis.js",
    "importStyle": "{getById}",
    "description": "Ask the backend for a Pronunciation Analysis.",
    "lineNumber": 31,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Object>} - The Pronunciation Analysis."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The ID of the corresponding challenge."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "analysisId",
        "description": "The ID of the analysis you want result for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object>"
      ],
      "spread": false,
      "description": "The Pronunciation Analysis."
    }
  },
  {
    "__docId__": 179,
    "kind": "function",
    "name": "prepare",
    "memberof": "src/api/challenges/pronunciation/analysis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/analysis.js~prepare",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/pronunciation/analysis.js",
    "importStyle": "{prepare}",
    "description": "Create a new analysis and return the ID.",
    "lineNumber": 40,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise|Promise<*>} - The result will hold the ID for the analysis."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise",
        "Promise<*>"
      ],
      "spread": false,
      "description": "The result will hold the ID for the analysis."
    },
    "params": []
  },
  {
    "__docId__": 180,
    "kind": "function",
    "name": "prepareChallenge",
    "memberof": "src/api/challenges/pronunciation/analysis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/analysis.js~prepareChallenge",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/pronunciation/analysis.js",
    "importStyle": "{prepareChallenge}",
    "description": "Prepare the backend by telling it which challenge it can expect by a new analysis.",
    "lineNumber": 51,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<*>} - Promise with the result of the init_challenge call."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "analysisId",
        "description": "The ID of the analysis to attache the challenge to."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challengeId",
        "description": "The ID of the challenge that belongs to a specific analysis."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "Promise with the result of the init_challenge call."
    }
  },
  {
    "__docId__": 181,
    "kind": "function",
    "name": "alignChallenge",
    "memberof": "src/api/challenges/pronunciation/analysis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/analysis.js~alignChallenge",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/pronunciation/analysis.js",
    "importStyle": "{alignChallenge}",
    "description": "A Pronunciation Challenge could hold an alignment already. If not so this function will instruct\nthe backend to create the alignment and return it to the client.",
    "lineNumber": 62,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<*>} - The alignment."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "analysisId",
        "description": "The ID of the analysis to create the alignment for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "The alignment."
    }
  },
  {
    "__docId__": 182,
    "kind": "function",
    "name": "prepareAudio",
    "memberof": "src/api/challenges/pronunciation/analysis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/analysis.js~prepareAudio",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/pronunciation/analysis.js",
    "importStyle": "{prepareAudio}",
    "description": "Prepare the backend for our audio.",
    "lineNumber": 73,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - Result of preparing the audio."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "analyseId",
        "description": "The Analysis that belongs to the audio."
      },
      {
        "nullable": null,
        "types": [
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The recorder to get specs from."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Result of preparing the audio."
    }
  },
  {
    "__docId__": 183,
    "kind": "function",
    "name": "streamAudio",
    "memberof": "src/api/challenges/pronunciation/analysis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/analysis.js~streamAudio",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/pronunciation/analysis.js",
    "importStyle": "{streamAudio}",
    "description": "Us the provided recorder to stream/send the recorded audio to the backend.",
    "lineNumber": 84,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - Stream result."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "analyseId",
        "description": "The ID of the analysis we're receiving audio for."
      },
      {
        "nullable": null,
        "types": [
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "Instance of an Recorder."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Stream result."
    }
  },
  {
    "__docId__": 184,
    "kind": "function",
    "name": "endStreamAudio",
    "memberof": "src/api/challenges/pronunciation/analysis.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/analysis.js~endStreamAudio",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/pronunciation/analysis.js",
    "importStyle": "{endStreamAudio}",
    "description": "Finishing the recording means we're ready to analyse! Smartest man in the entire universe.\nWe also accept a special callback that can be used to receive progress on.",
    "lineNumber": 96,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<*>} - The result will return the analysis."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "analyseId",
        "description": "The ID of the Analysis to analyse on."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "progressCb",
        "description": "A callback which will be used to receive progress on."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "The result will return the analysis."
    }
  },
  {
    "__docId__": 185,
    "kind": "file",
    "name": "src/api/challenges/pronunciation/index.js",
    "content": "/**\n * This file contains the readily available functions which interact with the\n * ITSLanguage pronunciation challenge API.\n */\n\nimport { authorisedRequest } from '../../communication';\n\n/**\n * The URL for the pronunciation challenge handler(s).\n * @type {string}\n */\nconst url = '/challenges/pronunciation';\n\n\n/**\n * Create a new pronunciation challenge.\n *\n * @param {Object} challenge - The pronunciation challenge to create.\n *\n * @returns {Promise} - The pronunciation challenge creation promise.\n */\nexport function create(challenge) {\n  return authorisedRequest('POST', url, challenge);\n}\n\n\n/**\n * Get a single pronunciation challenge by its ID.\n *\n * @param {string} id - The ID of the desired pronunciation challenge.\n *\n * @returns {Promise} - The promise for the pronunciation challenge.\n */\nexport function getById(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get a all pronunciation challenges.\n *\n * By default all pronunciation challenges are fetched though it is allowed to pass\n * filters as a `URLSearchParams` object.\n *\n * @param {URLSearchParams} [filters] - The filters to apply to the category list.\n *\n * @throws {Promise<string>} - If the given optional filters are not an instance of\n * `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the pronunciation challenges.\n */\nexport function getAll(filters) {\n  let urlWithFilters = url;\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject(new Error('The filters should be a `URLSearchParams` object.'));\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n\n\n/**\n * Delete the pronunciation challenge with the given ID.\n *\n * @param {string} id - The ID of the pronunciation challenge to delete.\n *\n * @returns {Promise} - The pronunciation delete promise.\n */\nexport function deleteChallenge(id) {\n  return authorisedRequest('DELETE', `${url}/${id}`);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/challenges/pronunciation/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 186,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/challenges/pronunciation/index.js",
    "static": true,
    "longname": "src/api/challenges/pronunciation/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/challenges/pronunciation/index.js",
    "importStyle": null,
    "description": "The URL for the pronunciation challenge handler(s).",
    "lineNumber": 12,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 187,
    "kind": "function",
    "name": "create",
    "memberof": "src/api/challenges/pronunciation/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/index.js~create",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/pronunciation/index.js",
    "importStyle": "{create}",
    "description": "Create a new pronunciation challenge.",
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The pronunciation challenge creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The pronunciation challenge to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The pronunciation challenge creation promise."
    }
  },
  {
    "__docId__": 188,
    "kind": "function",
    "name": "getById",
    "memberof": "src/api/challenges/pronunciation/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/index.js~getById",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/pronunciation/index.js",
    "importStyle": "{getById}",
    "description": "Get a single pronunciation challenge by its ID.",
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the pronunciation challenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired pronunciation challenge."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the pronunciation challenge."
    }
  },
  {
    "__docId__": 189,
    "kind": "function",
    "name": "getAll",
    "memberof": "src/api/challenges/pronunciation/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/index.js~getAll",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/pronunciation/index.js",
    "importStyle": "{getAll}",
    "description": "Get a all pronunciation challenges.\n\nBy default all pronunciation challenges are fetched though it is allowed to pass\nfilters as a `URLSearchParams` object.",
    "lineNumber": 52,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the pronunciation challenges."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the pronunciation challenges."
    },
    "throws": [
      {
        "types": [
          "Promise<string>"
        ],
        "description": "If the given optional filters are not an instance of\n`URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 190,
    "kind": "function",
    "name": "deleteChallenge",
    "memberof": "src/api/challenges/pronunciation/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/pronunciation/index.js~deleteChallenge",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/pronunciation/index.js",
    "importStyle": "{deleteChallenge}",
    "description": "Delete the pronunciation challenge with the given ID.",
    "lineNumber": 74,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The pronunciation delete promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the pronunciation challenge to delete."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The pronunciation delete promise."
    }
  },
  {
    "__docId__": 191,
    "kind": "file",
    "name": "src/api/challenges/speech/index.js",
    "content": "/**\n * This file contains the readily available functions which interact with the\n * ITSLanguage speech challenge API.\n */\n\nimport { authorisedRequest } from '../../communication';\n\n/**\n * The URL for the speech challenge handler(s).\n * @type {string}\n */\nconst url = '/challenges/speech';\n\n\n/**\n * Create a new speech challenge.\n *\n * @param {Object} challenge - The challenge to create.\n *\n * @returns {Promise} - The challenge creation promise.\n */\nexport function create(challenge) {\n  return authorisedRequest('POST', url, challenge);\n}\n\n\n/**\n * Get a single speech challenge by its ID.\n *\n * @param {string} id - The ID of the desired speech challenge.\n *\n * @returns {Promise} - The promise for the speech challenge.\n */\nexport function getById(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get a all speech challenges.\n *\n * By default all speech challenges are fetched though it is allowed to pass filters as a\n * `URLSearchParams` object.\n *\n * @param {URLSearchParams} [filters] - The filters to apply to the category list.\n *\n * @throws {Promise<string>} - If the given optional filters are not an instance of\n * `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the speech challenges.\n */\nexport function getAll(filters) {\n  let urlWithFilters = url;\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject(new Error('The filters should be a `URLSearchParams` object.'));\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/challenges/speech/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 192,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/challenges/speech/index.js",
    "static": true,
    "longname": "src/api/challenges/speech/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/challenges/speech/index.js",
    "importStyle": null,
    "description": "The URL for the speech challenge handler(s).",
    "lineNumber": 12,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 193,
    "kind": "function",
    "name": "create",
    "memberof": "src/api/challenges/speech/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/speech/index.js~create",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/speech/index.js",
    "importStyle": "{create}",
    "description": "Create a new speech challenge.",
    "lineNumber": 22,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The challenge creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The challenge to create."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The challenge creation promise."
    }
  },
  {
    "__docId__": 194,
    "kind": "function",
    "name": "getById",
    "memberof": "src/api/challenges/speech/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/speech/index.js~getById",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/speech/index.js",
    "importStyle": "{getById}",
    "description": "Get a single speech challenge by its ID.",
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the speech challenge."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired speech challenge."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the speech challenge."
    }
  },
  {
    "__docId__": 195,
    "kind": "function",
    "name": "getAll",
    "memberof": "src/api/challenges/speech/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/speech/index.js~getAll",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/speech/index.js",
    "importStyle": "{getAll}",
    "description": "Get a all speech challenges.\n\nBy default all speech challenges are fetched though it is allowed to pass filters as a\n`URLSearchParams` object.",
    "lineNumber": 52,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the speech challenges."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the speech challenges."
    },
    "throws": [
      {
        "types": [
          "Promise<string>"
        ],
        "description": "If the given optional filters are not an instance of\n`URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 196,
    "kind": "file",
    "name": "src/api/challenges/speech/recordings.js",
    "content": "/**\n * This file contains the readily available functions which interact with the ITSLanguage speech\n * recordings API.\n *\n * Note that this is one of the \"nested\" or \"composite\" APIs; You can only obtain the data if you\n * provide a reference to the challenge for which you want a recording.\n */\n\nimport {\n  encodeAndSendAudioOnDataAvailable,\n  prepareServerForAudio,\n  waitForUserMediaApproval,\n} from '../../utils/audio-over-socket';\nimport { authorisedRequest } from '../../communication';\nimport { makeWebsocketCall } from '../../communication/websocket';\n\n/**\n * The URL for the speech recording handler(s).\n *\n * @param challenge\n * @returns {string}\n */\nconst url = challenge => `/challenges/speech/${challenge}/recordings`;\n\n\n/**\n * Get a single speech recording by its ID.\n *\n * @param {string} challenge - The ID of the challenge for which the recording  was made.\n * @param {string} id - The ID of the desired speech recording.\n *\n * @returns {Promise} - The promise for the speech recording.\n */\nexport function getById(challenge, id) {\n  return authorisedRequest('GET', `${url(challenge)}/${id}`);\n}\n\n\n/**\n * Get a all speech recordings.\n *\n * By default all speech recordings are fetched though it is allowed to pass\n * filters as a `URLSearchParams` object.\n *\n * @param {string} challenge - The ID of the challenge for which the recording was made.\n * @param {URLSearchParams} [filters] - The filters to apply to the category list.\n *\n * @throws {Promise<string>} - If the given optional filters are not an instance of\n * `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the speech recordings.\n */\nexport function getAll(challenge, filters) {\n  let urlWithFilters = url(challenge);\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject(new Error('The filters should be a `URLSearchParams` object.'));\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n\n\n/**\n * Create a new recording for the given challenge with the data from the given recorder.\n *\n * @param {string} challenge - The ID of the challenge for which a recording is made.\n * @param {MediaRecorder} recorder - The recorder to use to get the recording.\n *\n * @emits {websocketserverreadyforaudio} - When the websocket server has been prepared for and is\n * ready to receive the audio.\n *\n * @returns {Promise} - The promise which resolves once the speech recording has successfully been\n * stored.\n */\nexport function record(challenge, recorder) {\n  return makeWebsocketCall('recording.init_recording')\n    // Initializing the recording ought to give us an ID for the recording we\n    // are creating right now.\n    .then(recording => makeWebsocketCall('recording.init_challenge', { args: [recording, challenge] }))\n    // We've linked it to the speech challenge now. We also should have\n    // received the recording ID once again.\n    .then(recording => waitForUserMediaApproval(recording, recorder))\n    // Alright, we should have permission to record the user. Time to prep the\n    // websocket server.\n    .then(recording => prepareServerForAudio(recording, recorder, 'recording.init_audio'))\n    // We've prepped the websocket server so it knows what audio format we are\n    // using and all the extra floof that comes with it.\n    .then(recording => encodeAndSendAudioOnDataAvailable(recording, recorder, 'recording.write'))\n    // When we are done; close the connection.\n    .then(recording => makeWebsocketCall('recording.close', { args: [recording] }));\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/challenges/speech/recordings.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 197,
    "kind": "function",
    "name": "url",
    "memberof": "src/api/challenges/speech/recordings.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/speech/recordings.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/challenges/speech/recordings.js",
    "importStyle": null,
    "description": "The URL for the speech recording handler(s).",
    "lineNumber": 23,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 198,
    "kind": "function",
    "name": "getById",
    "memberof": "src/api/challenges/speech/recordings.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/speech/recordings.js~getById",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/speech/recordings.js",
    "importStyle": "{getById}",
    "description": "Get a single speech recording by its ID.",
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the speech recording."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The ID of the challenge for which the recording  was made."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired speech recording."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the speech recording."
    }
  },
  {
    "__docId__": 199,
    "kind": "function",
    "name": "getAll",
    "memberof": "src/api/challenges/speech/recordings.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/speech/recordings.js~getAll",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/speech/recordings.js",
    "importStyle": "{getAll}",
    "description": "Get a all speech recordings.\n\nBy default all speech recordings are fetched though it is allowed to pass\nfilters as a `URLSearchParams` object.",
    "lineNumber": 53,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the speech recordings."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The ID of the challenge for which the recording was made."
      },
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the speech recordings."
    },
    "throws": [
      {
        "types": [
          "Promise<string>"
        ],
        "description": "If the given optional filters are not an instance of\n`URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 200,
    "kind": "function",
    "name": "record",
    "memberof": "src/api/challenges/speech/recordings.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/challenges/speech/recordings.js~record",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/challenges/speech/recordings.js",
    "importStyle": "{record}",
    "description": "Create a new recording for the given challenge with the data from the given recorder.",
    "lineNumber": 80,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise which resolves once the speech recording has successfully been\nstored."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "challenge",
        "description": "The ID of the challenge for which a recording is made."
      },
      {
        "nullable": null,
        "types": [
          "MediaRecorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The recorder to use to get the recording."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise which resolves once the speech recording has successfully been\nstored."
    },
    "emits": [
      {
        "types": [
          "websocketserverreadyforaudio"
        ],
        "description": "When the websocket server has been prepared for and is\nready to receive the audio."
      }
    ]
  },
  {
    "__docId__": 201,
    "kind": "file",
    "name": "src/api/communication/index.js",
    "content": "/**\n * This file contains the settings and the communication mechanism for the ITSLanguage REST API.\n */\n\n/**\n * Content-Type HTTP Header key.\n * @type {string}\n */\nconst CONTENT_TYPE = 'Content-Type';\n\n/**\n * Authorization HTTP Header key.\n * @type {string}\n */\nconst AUTHORIZATION = 'Authorization';\n\n/**\n * Content-Type HTTP Header value.\n * @type {string}\n */\nconst APPLICATION_JSON = 'application/json';\n\n\n/**\n * The settings to use for the communication with the ITSLanguage API.\n */\nexport const settings = {\n  apiUrl: 'https://api.itslanguage.nl',\n  wsUrl: null,\n  authorizationToken: null,\n};\n\n\n/**\n * Update the settings with the `newSettings`.\n *\n * @param {Object} newSettings - The settings to inject/update.\n *\n * @throws {Error} - When the given `newSettings` is something other than a object.\n */\nexport function updateSettings(newSettings) {\n  if (!newSettings || !(newSettings instanceof Object)) {\n    throw new Error('Please, only provide objects as settings.');\n  }\n\n  Object.assign(settings, newSettings);\n}\n\n\n/**\n * Parse the response of a fetch request.\n *\n * Try to parse the given response body as JSON, if it isn't Leave the response as is.\n *\n * @param {Response} response - The response to parse.\n *\n * @throws {Promise<string>} - When the request wasn't okay and the contents of the response isn't\n * json.\n * @throws {Promise<Error>} - When the request wasn't okay and the contents of the response is json.\n *\n * @returns {Promise|Response} - The contents of a JSON response or the response itself if the body\n * is something other than JSON.\n */\nfunction handleResponse(response) {\n  const responseContentType = response.headers.get(CONTENT_TYPE);\n\n  // The ITSLanguage API should return JSON. If t\n  if (responseContentType && responseContentType.includes(APPLICATION_JSON)) {\n    return response.json().then((json) => {\n      if (response.ok) {\n        return json;\n      }\n\n      return Promise.reject(json);\n    });\n  }\n\n  if (!response.ok) {\n    return Promise.reject(new Error(`${response.status}: ${response.statusText}`));\n  }\n\n  return response;\n}\n\n\n/**\n * Perform an HTTP request for the given method, url, body, and headers.\n *\n * In case the given url is a partial url, meaning it starts with a `/`, the base URL to the\n * ITSLanguage API is prepended.\n *\n * When a Object instance is provided as body, it'll be transformed into JSON. Unless it is either a\n * `URLSearchParams` or a `FormData` object. Anything else is sent as plain text.\n *\n * @param {string} method - The request METHOD ('GET', 'POST', 'PUT', 'DELETE').\n * @param {string} url - The location to send the request to.\n * @param {*} [body] - Anything which needs to be sent somewhere.\n * @param {Headers} [headers] - Extra headers to send with the request.\n *\n * @returns {Promise<Object>} The response of the made request.\n */\nexport function request(method, url, body, headers) {\n  const requestHeaders = headers || new Headers();\n\n  let requestBody = body;\n  if (!(body instanceof URLSearchParams || body instanceof FormData) && body instanceof Object) {\n    requestHeaders.set('Content-Type', 'application/json');\n    requestBody = JSON.stringify(body);\n  }\n\n  let requestURL = url;\n  // XXX remove the URL truthy check when all tests are properly written. Now\n  // it happens way to often that the URL is omitted without any good reason.\n  if (url && url.startsWith('/')) {\n    requestURL = `${settings.apiUrl}${url}`;\n  }\n\n  const requestOptions = {\n    method,\n    headers: requestHeaders,\n    body: requestBody,\n  };\n\n  return fetch(requestURL, requestOptions).then(handleResponse);\n}\n\n\n/**\n * Build a bearer token from the `authorizationToken` in the settings object.\n *\n * @throws {Error} When no authorizationToken is set.\n *\n * @returns {string} The generated bearer token.\n */\nfunction getBearerToken() {\n  if (!settings.authorizationToken) {\n    throw new Error('Please authenticate first.');\n  }\n\n  return `Bearer ${settings.authorizationToken}`;\n}\n\n\n/**\n * Perform an HTTP request with the desired method, body, and headers to the given partial\n * ITSLanguage API URL.\n *\n * This request will add the ``Authorization`` header to the request.\n *\n * This function only allows to make calls to the ITSLanguage API.\n *\n * @param {string} method - The request METHOD ('GET', 'POST', 'PUT', 'DELETE').\n * @param {string} url - The location to send the request to.\n * @param {*} [body] - Anything which needs to be sent somewhere.\n * @param {Headers} [headers] - Extra headers to send with the request.\n *\n * @throws {Promise<string>} - When the given `url` param is not a partial URL, or when there is no\n * authorisation token available.\n *\n * @returns {Promise<Object>} - The response from the ITSLanguage API.\n */\nexport function authorisedRequest(method, url, body, headers) {\n  // XXX remove the URL truthy check when all parts of the SDK no longer build\n  // a complete url by themselves using the \"private\" settings object of their\n  // connection reference.\n  if (url && (!url.startsWith('/') && !url.startsWith(settings.apiUrl))) {\n    return Promise.reject(new Error('Only relative ITSLanguage API URLs are allowed.'));\n  }\n\n  try {\n    const requestHeaders = headers || new Headers();\n    requestHeaders.set(AUTHORIZATION, getBearerToken());\n\n    return request(method, url, body, requestHeaders);\n  } catch (unauthorised) {\n    return Promise.reject(new Error(unauthorised.message));\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/communication/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 202,
    "kind": "variable",
    "name": "CONTENT_TYPE",
    "memberof": "src/api/communication/index.js",
    "static": true,
    "longname": "src/api/communication/index.js~CONTENT_TYPE",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/communication/index.js",
    "importStyle": null,
    "description": "Content-Type HTTP Header key.",
    "lineNumber": 9,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 203,
    "kind": "variable",
    "name": "AUTHORIZATION",
    "memberof": "src/api/communication/index.js",
    "static": true,
    "longname": "src/api/communication/index.js~AUTHORIZATION",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/communication/index.js",
    "importStyle": null,
    "description": "Authorization HTTP Header key.",
    "lineNumber": 15,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 204,
    "kind": "variable",
    "name": "APPLICATION_JSON",
    "memberof": "src/api/communication/index.js",
    "static": true,
    "longname": "src/api/communication/index.js~APPLICATION_JSON",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/communication/index.js",
    "importStyle": null,
    "description": "Content-Type HTTP Header value.",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 205,
    "kind": "variable",
    "name": "settings",
    "memberof": "src/api/communication/index.js",
    "static": true,
    "longname": "src/api/communication/index.js~settings",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/communication/index.js",
    "importStyle": "{settings}",
    "description": "The settings to use for the communication with the ITSLanguage API.",
    "lineNumber": 27,
    "type": {
      "types": [
        "{\"apiUrl\": string, \"wsUrl\": *, \"authorizationToken\": *}"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "function",
    "name": "updateSettings",
    "memberof": "src/api/communication/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/index.js~updateSettings",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/communication/index.js",
    "importStyle": "{updateSettings}",
    "description": "Update the settings with the `newSettings`.",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "newSettings",
        "description": "The settings to inject/update."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "When the given `newSettings` is something other than a object."
      }
    ],
    "return": null
  },
  {
    "__docId__": 207,
    "kind": "function",
    "name": "handleResponse",
    "memberof": "src/api/communication/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/index.js~handleResponse",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/communication/index.js",
    "importStyle": null,
    "description": "Parse the response of a fetch request.\n\nTry to parse the given response body as JSON, if it isn't Leave the response as is.",
    "lineNumber": 64,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise|Response} - The contents of a JSON response or the response itself if the body\nis something other than JSON."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Response"
        ],
        "spread": false,
        "optional": false,
        "name": "response",
        "description": "The response to parse."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise",
        "Response"
      ],
      "spread": false,
      "description": "The contents of a JSON response or the response itself if the body\nis something other than JSON."
    },
    "throws": [
      {
        "types": [
          "Promise<string>"
        ],
        "description": "When the request wasn't okay and the contents of the response isn't\njson."
      },
      {
        "types": [
          "Promise<Error>"
        ],
        "description": "When the request wasn't okay and the contents of the response is json."
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 208,
    "kind": "function",
    "name": "request",
    "memberof": "src/api/communication/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/index.js~request",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/communication/index.js",
    "importStyle": "{request}",
    "description": "Perform an HTTP request for the given method, url, body, and headers.\n\nIn case the given url is a partial url, meaning it starts with a `/`, the base URL to the\nITSLanguage API is prepended.\n\nWhen a Object instance is provided as body, it'll be transformed into JSON. Unless it is either a\n`URLSearchParams` or a `FormData` object. Anything else is sent as plain text.",
    "lineNumber": 102,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Object>} The response of the made request."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": "The request METHOD ('GET', 'POST', 'PUT', 'DELETE')."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "The location to send the request to."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "body",
        "description": "Anything which needs to be sent somewhere."
      },
      {
        "nullable": null,
        "types": [
          "Headers"
        ],
        "spread": false,
        "optional": true,
        "name": "headers",
        "description": "Extra headers to send with the request."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object>"
      ],
      "spread": false,
      "description": "The response of the made request."
    }
  },
  {
    "__docId__": 209,
    "kind": "function",
    "name": "getBearerToken",
    "memberof": "src/api/communication/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/index.js~getBearerToken",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/communication/index.js",
    "importStyle": null,
    "description": "Build a bearer token from the `authorizationToken` in the settings object.",
    "lineNumber": 135,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} The generated bearer token."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The generated bearer token."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "When no authorizationToken is set."
      }
    ],
    "params": [],
    "ignore": true
  },
  {
    "__docId__": 210,
    "kind": "function",
    "name": "authorisedRequest",
    "memberof": "src/api/communication/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/index.js~authorisedRequest",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/communication/index.js",
    "importStyle": "{authorisedRequest}",
    "description": "Perform an HTTP request with the desired method, body, and headers to the given partial\nITSLanguage API URL.\n\nThis request will add the ``Authorization`` header to the request.\n\nThis function only allows to make calls to the ITSLanguage API.",
    "lineNumber": 162,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Object>} - The response from the ITSLanguage API."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": "The request METHOD ('GET', 'POST', 'PUT', 'DELETE')."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "The location to send the request to."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "body",
        "description": "Anything which needs to be sent somewhere."
      },
      {
        "nullable": null,
        "types": [
          "Headers"
        ],
        "spread": false,
        "optional": true,
        "name": "headers",
        "description": "Extra headers to send with the request."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Object>"
      ],
      "spread": false,
      "description": "The response from the ITSLanguage API."
    },
    "throws": [
      {
        "types": [
          "Promise<string>"
        ],
        "description": "When the given `url` param is not a partial URL, or when there is no\nauthorisation token available."
      }
    ]
  },
  {
    "__docId__": 211,
    "kind": "file",
    "name": "src/api/communication/websocket.js",
    "content": "/**\n *\n */\n\nimport autobahn from 'autobahn';\nimport debug from 'debug';\nimport { settings } from './index';\n\nconst log = debug('its-sdk:WebSocket');\nconst error = debug('its-sdk:WebSocket');\nlog.log = console.log.bind(console);\n\n/**\n * Keep hold of the currently open autobahn connection.\n *\n * @type {Promise<autobahn.Connection>}\n */\nlet bundesautobahn;\n\n\n/**\n * Allow the `autobahn.Connection` to challenge the provided authentication.\n *\n * @param {autobahn.Session} session - The session of the current {@link autobahn.Connection}.\n * @param {string} method - The authentication method it tries to use.\n *\n * @throws {Error} - When the given `method` is unknown to the SDK.\n */\nfunction handleWebsocketAuthorisationChallenge(session, method) {\n  switch (method) {\n    case 'ticket':\n      return settings.authorizationToken;\n    default:\n      throw new Error('The websocket server tried to use the unknown '\n                      + `authentication challenge: \"${method}\"`);\n  }\n}\n\n\n/**\n * Set {@link bundesautobahn} to a new Promise which resolves into a `autobahn.Connection` object\n * when a connection was successfully established.\n *\n * @returns {Promise<autobahn.Connection>} - A promise which resolves when the connection was\n * successfully created and opened.\n */\nfunction establishNewBundesbahn() {\n  bundesautobahn = new Promise((resolve, reject) => {\n    const bahn = new autobahn.Connection({\n      url: settings.wsUrl,\n      realm: 'default',\n      // Of course we want to use es6 promises if they are available.\n      // But, the backend sometimes spits out progress. For that we need\n      // a When.JS promise..\n      use_es6_promises: false, // eslint-disable-line camelcase\n      // The following options are required in order to authorise the\n      // connection.\n      authmethods: ['ticket'],\n      authid: 'oauth2',\n      details: {\n        ticket: settings.authorizationToken,\n      },\n      onchallenge: handleWebsocketAuthorisationChallenge,\n    });\n\n    // `autobahn.Connection` calls its `onclose` method, if it exists, when it\n    // was not able to open a connection.\n    bahn.onclose = (/* reason, details */) => {\n      // When the connection failed to open a reason is given with some details.\n      // Sadly these are very un-descriptive. Therefore hint/warn the developer\n      // about potential erroneous settings or to contact us.\n      const message = 'The connection is erroneous; check if all required '\n                      + 'settings have been injected using the '\n                      + '`updateSettings()` function. If the problem persists '\n                      + 'please post a issue on our GitHub repository.';\n      reject(message);\n    };\n\n    // Connection got established; lets us it.\n    bahn.onopen = () => {\n      log('Successfully established a websocket connection.');\n      // Remove the `onclose` handler as it is no longer of interest to us.\n      delete bahn.onclose;\n      resolve(bahn);\n    };\n\n    bahn.open();\n  });\n\n  // Return the promise to make it this function chainable. In case the\n  // `bundesautobahn` is rejected; remove the reference so we can use simple\n  // falsy checks to determine if there is a connection.\n  return bundesautobahn.catch((reason) => {\n    bundesautobahn = null;\n    return Promise.reject(reason);\n  });\n}\n\n/**\n * Close the current websocket connection.\n *\n * @returns {Promise<string>} - A promise which will resolve as soon as the connection was\n * successfully closed.\n */\nexport function closeWebsocketConnection() {\n  if (!bundesautobahn) {\n    return Promise.resolve('There is no websocket connection to close.');\n  }\n\n  return bundesautobahn\n    .then((bahn) => {\n      try {\n        bahn.close();\n        bundesautobahn = null;\n        const message = 'The websocket connection has been closed successfully.';\n        log(message);\n        return message;\n      } catch (reason) {\n        // `autobahn.Connection.close()` throws a string when the connection is\n        // already closed. The connection is not exposed and therefore cannot be\n        // closed by anyone using the SDK. Regardless, when it happens just\n        // return a resolved promise.\n        bundesautobahn = null;\n        const message = 'The websocket connection has already been closed.';\n        error(message);\n        return message;\n      }\n    });\n}\n\n/**\n * Open a new websocket connection.\n *\n * There there currently is a open connection, close it and open a new connection.\n *\n * @returns {Promise<string>} - A resolved promise which resolves when the connection was\n * successfully created and opened.\n */\nexport function openWebsocketConnection() {\n  return closeWebsocketConnection()\n    .then(() => establishNewBundesbahn())\n    // `bundesautobahn` actually resolved with the `autobahn.Connection`\n    // object. This is only meant for internal usage and therefore should not\n    // be exposed to the users of the SDK.\n    .then(() => 'Successfully established a websocket connection.');\n}\n\n\n/**\n * Get the current websocket connection, or open a new one.\n *\n * If there is no current connection, open one and return that in stead.\n *\n * @returns {Promise<autobahn.Connection>} - The current websocket connection.\n */\nexport function getWebsocketConnection() {\n  if (!bundesautobahn) {\n    return establishNewBundesbahn();\n  }\n\n  return bundesautobahn;\n}\n\n\n/**\n * Make a rpc call to the ITSLanguage websocket server.\n *\n * This method will try to establish a websocket connection if there isn't one already.\n *\n * @param {string} rpc - The RPC to make. This be prepended by `nl.itslanguage` as the websocket\n * server only handles websocket calls when the RPC starts with that prefix.\n * @param {Object} [options] - Destructed object with options to pass to the websocket server.\n * @param {Array} [options.args] - An array with arguments to pass to the RPC.\n * @param {Object} [options.kwargs] - An object (dictionary) with arguments to pass to the RPC.\n * @param {Object} [options.options] - The options to pass to the RPC.\n * @param {Function} [options.progressCb] - Optional callback to receive progressed results.\n *\n * @returns {Promise<*>} - The response of the websocket call.\n */\nexport function makeWebsocketCall(rpc, {\n  args, kwargs, options, progressCb,\n} = {}) {\n  let mergedOptions = options;\n  if (progressCb) {\n    mergedOptions = {\n      ...options,\n      receive_progress: true, // eslint-disable-line camelcase\n    };\n  }\n  return getWebsocketConnection()\n    .then(connection => connection.session.call(`nl.itslanguage.${rpc}`, args, kwargs, mergedOptions)\n      .progress(progressCb))\n    .catch((result) => {\n      const { error: wssError, kwargs: wssKwargs, args: wssArgs } = result;\n\n      // Log the error to stderr\n      error(result);\n\n      // Return a slightly simplistic version of the error that occurred\n      return Promise.reject(new Error({\n        error: wssError,\n        ...wssKwargs,\n        args: [...wssArgs],\n      }));\n    });\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/communication/websocket.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 212,
    "kind": "variable",
    "name": "log",
    "memberof": "src/api/communication/websocket.js",
    "static": true,
    "longname": "src/api/communication/websocket.js~log",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/communication/websocket.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 213,
    "kind": "variable",
    "name": "error",
    "memberof": "src/api/communication/websocket.js",
    "static": true,
    "longname": "src/api/communication/websocket.js~error",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/communication/websocket.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 214,
    "kind": "function",
    "name": "handleWebsocketAuthorisationChallenge",
    "memberof": "src/api/communication/websocket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/websocket.js~handleWebsocketAuthorisationChallenge",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/communication/websocket.js",
    "importStyle": null,
    "description": "Allow the `autobahn.Connection` to challenge the provided authentication.",
    "lineNumber": 29,
    "params": [
      {
        "nullable": null,
        "types": [
          "autobahn.Session"
        ],
        "spread": false,
        "optional": false,
        "name": "session",
        "description": "The session of the current {@link autobahn.Connection}."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "method",
        "description": "The authentication method it tries to use."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "When the given `method` is unknown to the SDK."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 215,
    "kind": "function",
    "name": "establishNewBundesbahn",
    "memberof": "src/api/communication/websocket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/websocket.js~establishNewBundesbahn",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/communication/websocket.js",
    "importStyle": null,
    "description": "Set {@link bundesautobahn} to a new Promise which resolves into a `autobahn.Connection` object\nwhen a connection was successfully established.",
    "lineNumber": 47,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<autobahn.Connection>} - A promise which resolves when the connection was\nsuccessfully created and opened."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<autobahn.Connection>"
      ],
      "spread": false,
      "description": "A promise which resolves when the connection was\nsuccessfully created and opened."
    },
    "params": [],
    "ignore": true
  },
  {
    "__docId__": 216,
    "kind": "function",
    "name": "closeWebsocketConnection",
    "memberof": "src/api/communication/websocket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/websocket.js~closeWebsocketConnection",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/communication/websocket.js",
    "importStyle": "{closeWebsocketConnection}",
    "description": "Close the current websocket connection.",
    "lineNumber": 105,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<string>} - A promise which will resolve as soon as the connection was\nsuccessfully closed."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string>"
      ],
      "spread": false,
      "description": "A promise which will resolve as soon as the connection was\nsuccessfully closed."
    },
    "params": []
  },
  {
    "__docId__": 217,
    "kind": "function",
    "name": "openWebsocketConnection",
    "memberof": "src/api/communication/websocket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/websocket.js~openWebsocketConnection",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/communication/websocket.js",
    "importStyle": "{openWebsocketConnection}",
    "description": "Open a new websocket connection.\n\nThere there currently is a open connection, close it and open a new connection.",
    "lineNumber": 139,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<string>} - A resolved promise which resolves when the connection was\nsuccessfully created and opened."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string>"
      ],
      "spread": false,
      "description": "A resolved promise which resolves when the connection was\nsuccessfully created and opened."
    },
    "params": []
  },
  {
    "__docId__": 218,
    "kind": "function",
    "name": "getWebsocketConnection",
    "memberof": "src/api/communication/websocket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/websocket.js~getWebsocketConnection",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/communication/websocket.js",
    "importStyle": "{getWebsocketConnection}",
    "description": "Get the current websocket connection, or open a new one.\n\nIf there is no current connection, open one and return that in stead.",
    "lineNumber": 156,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<autobahn.Connection>} - The current websocket connection."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<autobahn.Connection>"
      ],
      "spread": false,
      "description": "The current websocket connection."
    },
    "params": []
  },
  {
    "__docId__": 219,
    "kind": "function",
    "name": "makeWebsocketCall",
    "memberof": "src/api/communication/websocket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/communication/websocket.js~makeWebsocketCall",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/communication/websocket.js",
    "importStyle": "{makeWebsocketCall}",
    "description": "Make a rpc call to the ITSLanguage websocket server.\n\nThis method will try to establish a websocket connection if there isn't one already.",
    "lineNumber": 180,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<*>} - The response of the websocket call."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rpc",
        "description": "The RPC to make. This be prepended by `nl.itslanguage` as the websocket\nserver only handles websocket calls when the RPC starts with that prefix."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "Destructed object with options to pass to the websocket server."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "options.args",
        "description": "An array with arguments to pass to the RPC."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.kwargs",
        "description": "An object (dictionary) with arguments to pass to the RPC."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options.options",
        "description": "The options to pass to the RPC."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "options.progressCb",
        "description": "Optional callback to receive progressed results."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "The response of the websocket call."
    }
  },
  {
    "__docId__": 220,
    "kind": "file",
    "name": "src/api/emailauth/index.js",
    "content": "/**\n * This file contains the readily available functions which interact with the ITSLanguage user API.\n * Users can have email based credentials. These credentials can be managed using the REST API.\n * Only users with administrative powers can perform these calls.\n *\n * @see {@link https://itslanguage.github.io/itslanguage-docs/api/emailauth/index.html}\n */\n\nimport { authorisedRequest } from '../communication';\n\n/**\n * The URL for the emailAuth handler.\n * According to the docs the following URL's are valid to be used for emailauth interaction.\n *\n * - POST `/users/emailauth`.\n * - POST `/users/:userId/emailauth`.\n *\n * @param {string} [userId] - The id of the user to interact with emailauth API.\n * @returns {string} - A composed URL to use for requests.\n */\nconst url = userId => `/user${userId ? `/${userId}` : ''}/emailauths`;\n\n/**\n * Create an emailAuth for either the current user or a user provided with an userId.\n * To create an email auth for another user you could pass the userId but depending on permissions\n * it could also be possible to use impersonation for this.\n *\n * @param {string} emailAuth - The Id of the user to create or overwrite a profile for.\n * @param {string} emailAuth.email - A unique email address.\n * @param {string} [emailAuth.password] - A secure password, if none is given, it will be generated.\n * @param {string} [userId=null] - The Id of the user to create an emailAuth for.\n *\n * @returns {Promise} - The emailAuth creation promise.\n */\n// eslint-disable-next-line import/prefer-default-export\nexport function create(emailAuth, userId = null) {\n  return authorisedRequest('POST', url(userId), emailAuth);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/emailauth/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 221,
    "kind": "function",
    "name": "url",
    "memberof": "src/api/emailauth/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/emailauth/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/emailauth/index.js",
    "importStyle": null,
    "description": "The URL for the emailAuth handler.\nAccording to the docs the following URL's are valid to be used for emailauth interaction.\n\n- POST `/users/emailauth`.\n- POST `/users/:userId/emailauth`.",
    "lineNumber": 21,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - A composed URL to use for requests."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "userId",
        "description": "The id of the user to interact with emailauth API."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "A composed URL to use for requests."
    },
    "ignore": true
  },
  {
    "__docId__": 222,
    "kind": "function",
    "name": "create",
    "memberof": "src/api/emailauth/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/emailauth/index.js~create",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/emailauth/index.js",
    "importStyle": "{create}",
    "description": "Create an emailAuth for either the current user or a user provided with an userId.\nTo create an email auth for another user you could pass the userId but depending on permissions\nit could also be possible to use impersonation for this.",
    "lineNumber": 36,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The emailAuth creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "emailAuth",
        "description": "The Id of the user to create or overwrite a profile for."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "emailAuth.email",
        "description": "A unique email address."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "emailAuth.password",
        "description": "A secure password, if none is given, it will be generated."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "userId",
        "description": "The Id of the user to create an emailAuth for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The emailAuth creation promise."
    }
  },
  {
    "__docId__": 223,
    "kind": "file",
    "name": "src/api/groups/index.js",
    "content": "/**\n * This file contains the readily available functions which interact with the ITSLanguage group API.\n *\n * Users can be part of zero or multiple groups.\n *\n * @see {@link https://itslanguage.github.io/itslanguage-docs/api/groups/index.html}\n */\n\nimport { authorisedRequest } from '../communication';\n\n/**\n * The URL for the group handler(s).\n * @type {string}\n */\nconst url = '/groups';\n\n\n/**\n * Create a new group.\n *\n * @param {Object} group - The group to create.\n * @param {string} [group.id] - A unique identifier. If none is given, one is generated.\n * @param {Array} group.name - The name of the group.\n *\n * @returns {Promise} - The group creation promise.\n */\nexport function create(group) {\n  return authorisedRequest('POST', url, group);\n}\n\n\n/**\n * Get a single group by its ID.\n *\n * @param {string} id - The ID of the desired group.\n *\n * @returns {Promise} - The promise for the group.\n */\nexport function getById(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get a all groups.\n *\n * By default all groups are fetched though it is allowed to pass filters as a `URLSearchParams`\n * object.\n *\n * @param {URLSearchParams} [filters] - The filters to apply to the category list.\n *\n * @throws {Promise<string>} - If the given optional filters are not an instance of\n * `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the groups.\n */\nexport function getAll(filters) {\n  let urlWithFilters = url;\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject(new Error('The filters should be a `URLSearchParams` object.'));\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/groups/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 224,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/groups/index.js",
    "static": true,
    "longname": "src/api/groups/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/groups/index.js",
    "importStyle": null,
    "description": "The URL for the group handler(s).",
    "lineNumber": 15,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 225,
    "kind": "function",
    "name": "create",
    "memberof": "src/api/groups/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/groups/index.js~create",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/groups/index.js",
    "importStyle": "{create}",
    "description": "Create a new group.",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The group creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "group",
        "description": "The group to create."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "group.id",
        "description": "A unique identifier. If none is given, one is generated."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "group.name",
        "description": "The name of the group."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The group creation promise."
    }
  },
  {
    "__docId__": 226,
    "kind": "function",
    "name": "getById",
    "memberof": "src/api/groups/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/groups/index.js~getById",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/groups/index.js",
    "importStyle": "{getById}",
    "description": "Get a single group by its ID.",
    "lineNumber": 39,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the group."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired group."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the group."
    }
  },
  {
    "__docId__": 227,
    "kind": "function",
    "name": "getAll",
    "memberof": "src/api/groups/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/groups/index.js~getAll",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/groups/index.js",
    "importStyle": "{getAll}",
    "description": "Get a all groups.\n\nBy default all groups are fetched though it is allowed to pass filters as a `URLSearchParams`\nobject.",
    "lineNumber": 57,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the groups."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the groups."
    },
    "throws": [
      {
        "types": [
          "Promise<string>"
        ],
        "description": "If the given optional filters are not an instance of\n`URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 228,
    "kind": "file",
    "name": "src/api/organisations/index.js",
    "content": "/**\n * This file contains the readily available functions which interact with the ITSLanguage\n * organisation API.\n */\n\nimport { authorisedRequest } from '../communication';\n\n/**\n * The URL for the organisation handler(s).\n * @type {string}\n */\nconst url = '/organisations';\n\n\n/**\n * Create a new organisation.\n *\n * @param {Object} organisation - The organisation to create.\n * @param {string} [organisation.id] - The organisation id. If none is given, one is generated.\n * @param {Array} organisation.name - The name of the organisation.\n *\n * @returns {Promise} - The organisation creation promise.\n */\nexport function create(organisation) {\n  return authorisedRequest('POST', url, organisation);\n}\n\n\n/**\n * Get a single organisation by its ID.\n *\n * @param {string} id - The ID of the desired organisation.\n *\n * @returns {Promise} - The promise for the organisation.\n */\nexport function getById(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get a all organisations.\n *\n * By default all organisations are fetched though it is allowed to pass filters as a\n * `URLSearchParams` object.\n *\n * @param {URLSearchParams} [filters] - The filters to apply to the category list.\n *\n * @throws {Promise<string>} - If the given optional filters are not an instance of\n * `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the organisations.\n */\nexport function getAll(filters) {\n  let urlWithFilters = url;\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject(new Error('The filters should be a `URLSearchParams` object.'));\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/organisations/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 229,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/organisations/index.js",
    "static": true,
    "longname": "src/api/organisations/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/organisations/index.js",
    "importStyle": null,
    "description": "The URL for the organisation handler(s).",
    "lineNumber": 12,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 230,
    "kind": "function",
    "name": "create",
    "memberof": "src/api/organisations/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/organisations/index.js~create",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/organisations/index.js",
    "importStyle": "{create}",
    "description": "Create a new organisation.",
    "lineNumber": 24,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The organisation creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "organisation",
        "description": "The organisation to create."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "organisation.id",
        "description": "The organisation id. If none is given, one is generated."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "organisation.name",
        "description": "The name of the organisation."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The organisation creation promise."
    }
  },
  {
    "__docId__": 231,
    "kind": "function",
    "name": "getById",
    "memberof": "src/api/organisations/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/organisations/index.js~getById",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/organisations/index.js",
    "importStyle": "{getById}",
    "description": "Get a single organisation by its ID.",
    "lineNumber": 36,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the organisation."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired organisation."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the organisation."
    }
  },
  {
    "__docId__": 232,
    "kind": "function",
    "name": "getAll",
    "memberof": "src/api/organisations/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/organisations/index.js~getAll",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/organisations/index.js",
    "importStyle": "{getAll}",
    "description": "Get a all organisations.\n\nBy default all organisations are fetched though it is allowed to pass filters as a\n`URLSearchParams` object.",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the organisations."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the organisations."
    },
    "throws": [
      {
        "types": [
          "Promise<string>"
        ],
        "description": "If the given optional filters are not an instance of\n`URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 233,
    "kind": "file",
    "name": "src/api/profile/index.js",
    "content": "/**\n * This file contains the readily available functions which interact with the ITSLanguage user API.\n * Profiles contain information about a User. A User does not need a Profile.\n *\n * @see {@link https://itslanguage.github.io/itslanguage-docs/api/profiles/index.html}\n */\n\nimport { authorisedRequest } from '../communication';\n\n/**\n * The URL for the profile handler(s).\n * According to the docs the following URL's are valid to be used for profile interaction.\n *\n * - POST/GET `/users/:userId/profile`.\n * - GET `/user/profile`.\n *\n * @param {string} [userId] - The id of the user to interact with profile API.\n * @returns {string} - A composed URL to use for requests.\n */\nconst url = userId => `/user${userId ? `s/${userId}` : ''}/profile`;\n\n\n/**\n * Link a profile to a user. If a user already has a profile, it will be overwritten.\n *\n * @param {string} userId - The Id of the user to create or overwrite a profile for.\n * @param {Object} profile - The profile containing information about the user.\n * @param {string} [profile.firstName] - The profile containing information about the user.\n * @param {string} [profile.lastName ] - The groups this user is part of.\n * @param {string} [profile.infix] - The names of roles to grant the user.\n * @param {string} [profile.gender] - The gender of the user.\n * @param {string} [profile.birthDate] - The birthDate of the user. In the proper ISO 8601 format.\n *\n * @returns {Promise} - The user creation promise.\n */\nexport function create(userId, profile) {\n  return authorisedRequest('POST', url(userId), profile);\n}\n\n\n/**\n * Get profile for the current user.\n *\n * @returns {Promise} - The current user.\n */\nexport function getCurrent() {\n  return authorisedRequest('GET', url());\n}\n\n/**\n * Get a profile for a user by its Id.\n *\n * @param {string} id - The Id of the desired user.\n *\n * @returns {Promise} - The promise for the profile of the requested user.\n */\nexport function getById(id) {\n  return authorisedRequest('GET', url(id));\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/profile/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 234,
    "kind": "function",
    "name": "url",
    "memberof": "src/api/profile/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/profile/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/profile/index.js",
    "importStyle": null,
    "description": "The URL for the profile handler(s).\nAccording to the docs the following URL's are valid to be used for profile interaction.\n\n- POST/GET `/users/:userId/profile`.\n- GET `/user/profile`.",
    "lineNumber": 20,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - A composed URL to use for requests."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "userId",
        "description": "The id of the user to interact with profile API."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "A composed URL to use for requests."
    },
    "ignore": true
  },
  {
    "__docId__": 235,
    "kind": "function",
    "name": "create",
    "memberof": "src/api/profile/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/profile/index.js~create",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/profile/index.js",
    "importStyle": "{create}",
    "description": "Link a profile to a user. If a user already has a profile, it will be overwritten.",
    "lineNumber": 36,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The user creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": "The Id of the user to create or overwrite a profile for."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "profile",
        "description": "The profile containing information about the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "profile.firstName",
        "description": "The profile containing information about the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "profile.lastName",
        "description": "The groups this user is part of."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "profile.infix",
        "description": "The names of roles to grant the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "profile.gender",
        "description": "The gender of the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "profile.birthDate",
        "description": "The birthDate of the user. In the proper ISO 8601 format."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The user creation promise."
    }
  },
  {
    "__docId__": 236,
    "kind": "function",
    "name": "getCurrent",
    "memberof": "src/api/profile/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/profile/index.js~getCurrent",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/profile/index.js",
    "importStyle": "{getCurrent}",
    "description": "Get profile for the current user.",
    "lineNumber": 46,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The current user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The current user."
    },
    "params": []
  },
  {
    "__docId__": 237,
    "kind": "function",
    "name": "getById",
    "memberof": "src/api/profile/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/profile/index.js~getById",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/profile/index.js",
    "importStyle": "{getById}",
    "description": "Get a profile for a user by its Id.",
    "lineNumber": 57,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the profile of the requested user."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The Id of the desired user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the profile of the requested user."
    }
  },
  {
    "__docId__": 238,
    "kind": "file",
    "name": "src/api/progress/index.js",
    "content": "/**\n * The progress of a category (or actually, challenges in a category) can be requested by a user.\n *\n * @see {@link https://itslanguage.github.io/itslanguage-docs/api/progress/index.html}\n */\n\nimport { authorisedRequest } from '../communication';\n\n/**\n * The URL for the category handler(s) to query for progress.\n * @type {string}\n */\nconst url = '/categories';\n\n/**\n * Get progress by its category id.\n * The progress is returned for the current user if only the id is passed. If groups and or a role\n * is passed it will return progress for all users from that group.\n *\n * @param {string} id - The category id.\n * @param {Array} [groups=[]] - The id's of the groups to get progress on.\n * @param {string} [role=''] - The id of the role that a user should be in.\n *\n * @returns {Promise} - The promise for the organisation.\n */\n// eslint-disable-next-line import/prefer-default-export\nexport function getById(id, groups = [], role = '') {\n  let filters = '';\n  const searchParams = new URLSearchParams();\n\n  if (groups.length) {\n    // If we have groups, add them to the searchParams!\n    groups.forEach((group) => {\n      searchParams.append('group', group);\n    });\n  }\n\n  if (role !== '') {\n    // Do we role with a role? Add it to the searchParams!\n    searchParams.append('role', role);\n  }\n\n  if (groups.length || role) {\n    // If we had groups or roles, construct a querystring based on searchParams.\n    filters = `?${searchParams.toString()}`;\n  }\n\n  return authorisedRequest('GET', `${url}/${id}/progress${filters}`);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/progress/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 239,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/progress/index.js",
    "static": true,
    "longname": "src/api/progress/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/progress/index.js",
    "importStyle": null,
    "description": "The URL for the category handler(s) to query for progress.",
    "lineNumber": 13,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 240,
    "kind": "function",
    "name": "getById",
    "memberof": "src/api/progress/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/progress/index.js~getById",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/progress/index.js",
    "importStyle": "{getById}",
    "description": "Get progress by its category id.\nThe progress is returned for the current user if only the id is passed. If groups and or a role\nis passed it will return progress for all users from that group.",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the organisation."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The category id."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[]",
        "defaultRaw": [],
        "name": "groups",
        "description": "The id's of the groups to get progress on."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "''",
        "defaultRaw": "''",
        "name": "role",
        "description": "The id of the role that a user should be in."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the organisation."
    }
  },
  {
    "__docId__": 241,
    "kind": "file",
    "name": "src/api/roles/index.js",
    "content": "/**\n * This file contains the readily available functions which interact with the ITSLanguage role API.\n *\n * Roles are named groups of permissions. A role is typically assigned to a user to grant a user\n * permissions.\n *\n * @see {@link https://itslanguage.github.io/itslanguage-docs/api/roles/index.html}\n */\n\nimport { authorisedRequest } from '../communication';\n\n/**\n * The URL for the role handler(s).\n * @type {string}\n */\nconst url = '/roles';\n\n/**\n * Create a new role.\n *\n * @param {Object} role - The role to create.\n * @param {string} [role.id] - The category identifier. If none is given, one is generated.\n * @param {Array} role.permissions - Array of permissions this role is authorized for.\n *\n * @returns {Promise} - The user creation promise.\n */\nexport function create(role) {\n  return authorisedRequest('POST', url, role);\n}\n\n/**\n * Get a single role by its ID.\n *\n * @param {string} id - The ID of the desired role.\n *\n * @returns {Promise} - The promise for the role.\n */\nexport function getById(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get a all roles.\n *\n * By default all roles are fetched though it is allowed to pass filters as a `URLSearchParams`\n * object.\n *\n * @param {URLSearchParams} [filters] - The filters to apply to the category list.\n *\n * @throws {Promise<string>} - If the given optional filters are not an instance of\n * `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the roles.\n */\nexport function getAll(filters) {\n  let urlWithFilters = url;\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject(new Error('The filters should be a `URLSearchParams` object.'));\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/roles/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 242,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/roles/index.js",
    "static": true,
    "longname": "src/api/roles/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/roles/index.js",
    "importStyle": null,
    "description": "The URL for the role handler(s).",
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 243,
    "kind": "function",
    "name": "create",
    "memberof": "src/api/roles/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/roles/index.js~create",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/roles/index.js",
    "importStyle": "{create}",
    "description": "Create a new role.",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The user creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "role",
        "description": "The role to create."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "role.id",
        "description": "The category identifier. If none is given, one is generated."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "role.permissions",
        "description": "Array of permissions this role is authorized for."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The user creation promise."
    }
  },
  {
    "__docId__": 244,
    "kind": "function",
    "name": "getById",
    "memberof": "src/api/roles/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/roles/index.js~getById",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/roles/index.js",
    "importStyle": "{getById}",
    "description": "Get a single role by its ID.",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the role."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired role."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the role."
    }
  },
  {
    "__docId__": 245,
    "kind": "function",
    "name": "getAll",
    "memberof": "src/api/roles/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/roles/index.js~getAll",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/roles/index.js",
    "importStyle": "{getAll}",
    "description": "Get a all roles.\n\nBy default all roles are fetched though it is allowed to pass filters as a `URLSearchParams`\nobject.",
    "lineNumber": 56,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the roles."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the roles."
    },
    "throws": [
      {
        "types": [
          "Promise<string>"
        ],
        "description": "If the given optional filters are not an instance of\n`URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 246,
    "kind": "file",
    "name": "src/api/tenants/index.js",
    "content": "/**\n * This file contains the readily available functions which interact with the ITSLanguage role API.\n *\n * Tenants can be managed using the REST API.\n * Only users with administrative powers can perform these calls.\n *\n * @see {@link https://itslanguage.github.io/itslanguage-docs/api/tenants/index.html}\n */\n\nimport { authorisedRequest } from '../communication';\n\n/**\n * The URL for the tenant handler(s).\n * @type {string}\n */\nconst url = '/tenants';\n\n/**\n * Create a new tenant.\n *\n * @param {Object} tenant - The tenant to create.\n * @param {string} [tenant.id] - A unique identifier. If none is given, one is generated.\n * @param {Array} tenant.name - The name of the tenant.\n *\n * @returns {Promise} - The user creation promise.\n */\nexport function create(tenant) {\n  return authorisedRequest('POST', url, tenant);\n}\n\n/**\n * Get a tenant by its ID.\n *\n * @param {string} id - The Id of the desired tenant.\n *\n * @returns {Promise} - The promise for the tenant.\n */\nexport function getById(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get all tenants.\n *\n * @returns {Promise} - The promise for the tenants.\n */\nexport function getAll() {\n  return authorisedRequest('GET', url);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/tenants/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 247,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/tenants/index.js",
    "static": true,
    "longname": "src/api/tenants/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/tenants/index.js",
    "importStyle": null,
    "description": "The URL for the tenant handler(s).",
    "lineNumber": 16,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 248,
    "kind": "function",
    "name": "create",
    "memberof": "src/api/tenants/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/tenants/index.js~create",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/tenants/index.js",
    "importStyle": "{create}",
    "description": "Create a new tenant.",
    "lineNumber": 27,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The user creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "tenant",
        "description": "The tenant to create."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "tenant.id",
        "description": "A unique identifier. If none is given, one is generated."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "tenant.name",
        "description": "The name of the tenant."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The user creation promise."
    }
  },
  {
    "__docId__": 249,
    "kind": "function",
    "name": "getById",
    "memberof": "src/api/tenants/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/tenants/index.js~getById",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/tenants/index.js",
    "importStyle": "{getById}",
    "description": "Get a tenant by its ID.",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the tenant."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The Id of the desired tenant."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the tenant."
    }
  },
  {
    "__docId__": 250,
    "kind": "function",
    "name": "getAll",
    "memberof": "src/api/tenants/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/tenants/index.js~getAll",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/tenants/index.js",
    "importStyle": "{getAll}",
    "description": "Get all tenants.",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the tenants."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the tenants."
    },
    "params": []
  },
  {
    "__docId__": 251,
    "kind": "file",
    "name": "src/api/users/index.js",
    "content": "/**\n * This file contains the readily available functions which interact with the ITSLanguage user API.\n *\n * @see {@link https://itslanguage.github.io/itslanguage-docs/api/users/index.html}\n */\n\nimport { authorisedRequest } from '../communication';\n\n/**\n * The URL for the user handler(s).\n * @type {string}\n */\nconst url = '/users';\n\n/**\n * The URL for a single user handler.\n * @type {string}\n */\nconst singleUserUrl = '/user';\n\n\n/**\n * Create a new user.\n *\n * @param {Object} user - The user to create.\n * @param {string} [user.id] - A unique identifier. If none is given, one is generated.\n * @param {string} user.firstName - The first name of the user.\n * @param {string} user.infix - The infix of the user.\n * @param {string} user.lastName - The last name of the user.\n * @param {Array} [user.groups] - Groups the user resides in.\n * @param {Array} user.roles - The names of roles to grant the user.\n *\n * @returns {Promise} - The user creation promise.\n */\nexport function create(user) {\n  return authorisedRequest('POST', url, user);\n}\n\n\n/**\n * Get the current user.\n *\n * @returns {Promise} - The current user.\n */\nexport function getCurrent() {\n  return authorisedRequest('GET', singleUserUrl);\n}\n\n/**\n * Get a single user by its ID.\n *\n * @param {string} id - The ID of the desired user.\n *\n * @returns {Promise} - The promise for the user.\n */\nexport function getById(id) {\n  return authorisedRequest('GET', `${url}/${id}`);\n}\n\n\n/**\n * Get a all users.\n *\n * By default all users are fetched though it is allowed to pass filters as a `URLSearchParams`\n * object.\n *\n * @param {URLSearchParams} [filters] - The filters to apply to the category list.\n *\n * @throws {Promise<string>} - If the given optional filters are not an instance of\n * `URLSearchParams`.\n *\n * @returns {Promise} - The promise for the users.\n */\nexport function getAll(filters) {\n  let urlWithFilters = url;\n\n  if (filters) {\n    if (!(filters instanceof URLSearchParams)) {\n      return Promise.reject(new Error('The filters should be a `URLSearchParams` object.'));\n    }\n\n    urlWithFilters += `?${filters.toString()}`;\n  }\n\n  return authorisedRequest('GET', urlWithFilters);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/users/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 252,
    "kind": "variable",
    "name": "url",
    "memberof": "src/api/users/index.js",
    "static": true,
    "longname": "src/api/users/index.js~url",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/users/index.js",
    "importStyle": null,
    "description": "The URL for the user handler(s).",
    "lineNumber": 13,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 253,
    "kind": "variable",
    "name": "singleUserUrl",
    "memberof": "src/api/users/index.js",
    "static": true,
    "longname": "src/api/users/index.js~singleUserUrl",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/api/users/index.js",
    "importStyle": null,
    "description": "The URL for a single user handler.",
    "lineNumber": 19,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 254,
    "kind": "function",
    "name": "create",
    "memberof": "src/api/users/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/users/index.js~create",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/users/index.js",
    "importStyle": "{create}",
    "description": "Create a new user.",
    "lineNumber": 35,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The user creation promise."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": "The user to create."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "user.id",
        "description": "A unique identifier. If none is given, one is generated."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user.firstName",
        "description": "The first name of the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user.infix",
        "description": "The infix of the user."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user.lastName",
        "description": "The last name of the user."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": true,
        "name": "user.groups",
        "description": "Groups the user resides in."
      },
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "user.roles",
        "description": "The names of roles to grant the user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The user creation promise."
    }
  },
  {
    "__docId__": 255,
    "kind": "function",
    "name": "getCurrent",
    "memberof": "src/api/users/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/users/index.js~getCurrent",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/users/index.js",
    "importStyle": "{getCurrent}",
    "description": "Get the current user.",
    "lineNumber": 45,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The current user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The current user."
    },
    "params": []
  },
  {
    "__docId__": 256,
    "kind": "function",
    "name": "getById",
    "memberof": "src/api/users/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/users/index.js~getById",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/users/index.js",
    "importStyle": "{getById}",
    "description": "Get a single user by its ID.",
    "lineNumber": 56,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the user."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The ID of the desired user."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the user."
    }
  },
  {
    "__docId__": 257,
    "kind": "function",
    "name": "getAll",
    "memberof": "src/api/users/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/users/index.js~getAll",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/users/index.js",
    "importStyle": "{getAll}",
    "description": "Get a all users.\n\nBy default all users are fetched though it is allowed to pass filters as a `URLSearchParams`\nobject.",
    "lineNumber": 74,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise for the users."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "URLSearchParams"
        ],
        "spread": false,
        "optional": true,
        "name": "filters",
        "description": "The filters to apply to the category list."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise for the users."
    },
    "throws": [
      {
        "types": [
          "Promise<string>"
        ],
        "description": "If the given optional filters are not an instance of\n`URLSearchParams`."
      }
    ]
  },
  {
    "__docId__": 258,
    "kind": "file",
    "name": "src/api/utils/audio-over-socket.js",
    "content": "/**\n * This file contains some re-usable parts for websocket audio communication.\n */\n\nimport autobahn from 'autobahn';\nimport { getWebsocketConnection, makeWebsocketCall } from '../communication/websocket';\nimport broadcaster from '../broadcaster';\nimport { createWAVEHeader } from '../../audio/wave-packer';\nimport { dataToBase64 } from './index';\n\n\n/**\n * Encode the audio as base64 and send it to the websocket server.\n *\n * @param {string} id - The reserved ID for the audio.\n * @param {MediaRecorder|Recorder} recorder - The recorder to use to get the recording.\n * @param {string} rpc - The RPC to use to store the data.\n *\n * @returns {Promise<*>} - The response of the given RPC.\n */\nexport function encodeAndSendAudioOnDataAvailable(id, recorder, rpc) {\n  return new Promise((resolve, reject) => {\n    // When the audio is done recording: encode the data, send it to the\n    // websocket server and continue with the chain.\n    recorder.addEventListener('dataavailable', (chunk) => {\n      const encoded = dataToBase64(chunk);\n      makeWebsocketCall(rpc, { args: [id, encoded, 'base64'] })\n        .then(resolve, reject);\n    });\n  });\n}\n\n/**\n * Register a RPC call to the current websocket connection. The backend will call this registered\n * function once, an then we can send progressive results (the details.progress call) to send audio\n * chunks to the backend. We will send those chunks as soon as we got audio from the recorder.\n *\n * When the recording ends we un-register the rpc.\n *\n * @todo make the unregistering more solid. It can break way to easy now. One way could be, for\n * example, to keep a list of registered RPC's and set a timer to unregister them.\n *\n * @param {Recorder} recorder - Audio recorder instance.\n * @param {string} rpcName - Name of the RPC to register. This name will be prepended with\n * nl.itslanguage for better consistency.\n * @returns {Promise<any>} - It returns a promise with the service registration as result.\n */\nexport function registerStreamForRecorder(recorder, rpcName) {\n  const rpc = `nl.itslanguage.${rpcName}`;\n  let rpcRegistration = null;\n\n  /**\n   * This is the actual RPC function that the backend will call. We need to make use of the\n   * autobahn deferred object (based on When.js, an older version) to be able to use progressive\n   * calls. Native promises don't support progressive result (it is not in the Promise A+ spec).\n   *\n   * For the audio chunks we assume to send audio according to the WAVE format. For this to happen\n   * we need to prepend our raw data with a WAVE file header. We do this as first step if data\n   * becomes available.\n   *\n   * When sending audio gets paused, which will be the case for the pause and resume functionality,\n   * we will resend the header after resuming. The API docs cover the need for this. Check there for\n   * more information.\n   *\n   * @see https://github.com/crossbario/autobahn-js/blob/master/doc/reference.md#register\n   * @see https://github.com/crossbario/autobahn-js/blob/master/doc/reference.md#progressive-results\n   *\n   * @param {Array} args - Argument list.\n   * @param {Object} kwargs - Key-valued argument list.\n   * @param {Object} details - Details, just as the progress function.\n   * @returns {Promise} - A promise that can be resolved to end the asynchronous behaviour of this\n   * registered RCP.\n   */\n  function sendAudioChunks(args, kwargs, details) {\n    // eslint-disable-next-line new-cap\n    const defer = new autobahn.when.defer();\n    const { audioParameters: { channels, sampleRate } } = recorder.getAudioSpecs();\n    const headerArrBuff = createWAVEHeader(channels, sampleRate);\n    const header = Array.from(new Uint8Array(headerArrBuff));\n    let sendHeader = true;\n\n    if (details.progress) {\n      // Listen for recording events.\n      recorder.addEventListener('dataavailable', (chuck) => {\n        if (sendHeader) {\n          // Sent the empty wave header first, this is needed\n          // for containerized WAVE files.\n          details.progress([header]);\n          sendHeader = false;\n        }\n\n        // Send the data chunks to the backend! Whoop whoop!\n        const dataToSend = Array.from(new Uint8Array(chuck));\n        details.progress([dataToSend]);\n      });\n\n      // Recording is done. Resolve and unregister now please!\n      recorder.addEventListener('recorded', () => {\n        defer.resolve();\n        if (rpcRegistration) {\n          getWebsocketConnection()\n            .then(connection => connection.session.unregister(rpcRegistration));\n        }\n        recorder.removeAllEventListeners();\n      });\n\n      // In case of a pause, make sure next chunk of data will\n      // get the header (again).\n      recorder.addEventListener('paused', () => {\n        sendHeader = true;\n      });\n    }\n\n    return defer.promise;\n  }\n\n  // Start registering a RPC call. As a result, this function will return a promise with the\n  // registration of the RPC as result.\n  return new Promise((resolve) => {\n    getWebsocketConnection().then((connection) => {\n      connection.session.register(rpc, sendAudioChunks).then((registration) => {\n        // Registering done. Save it so we can un-register later on.\n        rpcRegistration = registration;\n        // We've prepped the websocket server, now it can receive audio. Broadcast\n        // that it is allowed to record.\n        broadcaster.emit('websocketserverreadyforaudio');\n        resolve(registration);\n      });\n    });\n  });\n}\n\n/**\n * Send the recorder settings to the websocket server to initialize it.\n *\n * The reserved ID (passed in the parameters) is returned once the promise is resolved.\n *\n * @param {string} id - The reserved ID for the audio.\n * @param {MediaRecorder|Recorder} recorder - The recorder which has been set up to record.\n * @param {string} rpc - The RPC to use to initialize the websocket server.\n *\n * @emits {websocketserverreadyforaudio} - When the websocket server has been prepared for and is\n * ready to receive the audio.\n *\n * @returns {Promise} - The promise which resolves when the websocket server is ready for the audio.\n */\nexport function prepareServerForAudio(id, recorder, rpc) {\n  const { audioFormat, audioParameters } = recorder.getAudioSpecs();\n  return makeWebsocketCall(rpc, { args: [id, audioFormat], kwargs: audioParameters })\n    .then(() => {\n      // We've prepped the websocket server, now it can receive audio. Broadcast\n      // that it is allowed to record.\n      broadcaster.emit('websocketserverreadyforaudio');\n      return id;\n    });\n}\n\n\n/**\n * Wait for the recorder to get the permission for user media.\n *\n * The reserved ID (passed in the parameters) is returned once the promise is resolved.\n *\n * @param {string} id - The reserved ID for the audio.\n * @param {MediaRecorder|Recorder} recorder - The recorder for which to wait.\n *\n * @returns {Promise} - The promise which resolves if the user has allowed us to record them.\n */\nexport function waitForUserMediaApproval(id, recorder) {\n  return new Promise((resolve) => {\n    // We need the user's permission in order to record the audio. Wait for\n    // it if we don't have it already.\n    if (recorder.hasUserMediaApproval()) {\n      resolve();\n    } else {\n      recorder.addEventListener('ready', resolve);\n    }\n  }).then(() => id);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/utils/audio-over-socket.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 259,
    "kind": "function",
    "name": "encodeAndSendAudioOnDataAvailable",
    "memberof": "src/api/utils/audio-over-socket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/utils/audio-over-socket.js~encodeAndSendAudioOnDataAvailable",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/utils/audio-over-socket.js",
    "importStyle": "{encodeAndSendAudioOnDataAvailable}",
    "description": "Encode the audio as base64 and send it to the websocket server.",
    "lineNumber": 21,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<*>} - The response of the given RPC."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The reserved ID for the audio."
      },
      {
        "nullable": null,
        "types": [
          "MediaRecorder",
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The recorder to use to get the recording."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rpc",
        "description": "The RPC to use to store the data."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "The response of the given RPC."
    }
  },
  {
    "__docId__": 260,
    "kind": "function",
    "name": "registerStreamForRecorder",
    "memberof": "src/api/utils/audio-over-socket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/utils/audio-over-socket.js~registerStreamForRecorder",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/utils/audio-over-socket.js",
    "importStyle": "{registerStreamForRecorder}",
    "description": "Register a RPC call to the current websocket connection. The backend will call this registered\nfunction once, an then we can send progressive results (the details.progress call) to send audio\nchunks to the backend. We will send those chunks as soon as we got audio from the recorder.\n\nWhen the recording ends we un-register the rpc.",
    "lineNumber": 48,
    "todo": [
      "make the unregistering more solid. It can break way to easy now. One way could be, for\nexample, to keep a list of registered RPC's and set a timer to unregister them."
    ],
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<any>} - It returns a promise with the service registration as result."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "Audio recorder instance."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rpcName",
        "description": "Name of the RPC to register. This name will be prepended with\nnl.itslanguage for better consistency."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<any>"
      ],
      "spread": false,
      "description": "It returns a promise with the service registration as result."
    }
  },
  {
    "__docId__": 261,
    "kind": "function",
    "name": "prepareServerForAudio",
    "memberof": "src/api/utils/audio-over-socket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/utils/audio-over-socket.js~prepareServerForAudio",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/utils/audio-over-socket.js",
    "importStyle": "{prepareServerForAudio}",
    "description": "Send the recorder settings to the websocket server to initialize it.\n\nThe reserved ID (passed in the parameters) is returned once the promise is resolved.",
    "lineNumber": 147,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise which resolves when the websocket server is ready for the audio."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The reserved ID for the audio."
      },
      {
        "nullable": null,
        "types": [
          "MediaRecorder",
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The recorder which has been set up to record."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rpc",
        "description": "The RPC to use to initialize the websocket server."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise which resolves when the websocket server is ready for the audio."
    },
    "emits": [
      {
        "types": [
          "websocketserverreadyforaudio"
        ],
        "description": "When the websocket server has been prepared for and is\nready to receive the audio."
      }
    ]
  },
  {
    "__docId__": 262,
    "kind": "function",
    "name": "waitForUserMediaApproval",
    "memberof": "src/api/utils/audio-over-socket.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/utils/audio-over-socket.js~waitForUserMediaApproval",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/utils/audio-over-socket.js",
    "importStyle": "{waitForUserMediaApproval}",
    "description": "Wait for the recorder to get the permission for user media.\n\nThe reserved ID (passed in the parameters) is returned once the promise is resolved.",
    "lineNumber": 169,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - The promise which resolves if the user has allowed us to record them."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "The reserved ID for the audio."
      },
      {
        "nullable": null,
        "types": [
          "MediaRecorder",
          "Recorder"
        ],
        "spread": false,
        "optional": false,
        "name": "recorder",
        "description": "The recorder for which to wait."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "The promise which resolves if the user has allowed us to record them."
    }
  },
  {
    "__docId__": 263,
    "kind": "file",
    "name": "src/api/utils/index.js",
    "content": "/**\n * Some all-round re-usable utilities.\n */\n\n/**\n * Convert the given ArrayBuffer to a base64 encoded string.\n *\n * @param {ArrayBuffer} data - The data to transform to base64.\n *\n * @returns {string} - The base64 encoded data.\n */\nexport function dataToBase64(data) { // eslint-disable-line import/prefer-default-export\n  let binary = '';\n  const bytes = new Uint8Array(data);\n  const len = bytes.byteLength;\n  for (let i = 0; i < len; i += 1) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return window.btoa(binary);\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/api/utils/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 264,
    "kind": "function",
    "name": "dataToBase64",
    "memberof": "src/api/utils/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/api/utils/index.js~dataToBase64",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/api/utils/index.js",
    "importStyle": "{dataToBase64}",
    "description": "Convert the given ArrayBuffer to a base64 encoded string.",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} - The base64 encoded data."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "The data to transform to base64."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The base64 encoded data."
    }
  },
  {
    "__docId__": 265,
    "kind": "file",
    "name": "src/audio/audio-player.js",
    "content": "import allOff from 'event-emitter/all-off';\nimport ee from 'event-emitter';\nimport Stopwatch from './tools';\nimport WebAudioPlayer from './web-audio-player';\n/**\n * ITSLanguage AudioPlayer non-graphical component.\n */\nexport default class AudioPlayer {\n  /**\n   * Construct an AudioPlayer for playing .wav or .mp3 files.\n   *\n   * @param {?Object} options - Override any of the default settings.\n   * @emits {Event} 'playbackstopped' When playback has ended, been stopped or been paused.\n   * @emits {Event} All events the HTML5 Audio also fires. {@link http://www.w3schools.com/tags/ref_av_dom.asp}\n   */\n  constructor(options) {\n    /**\n     * @type {Object}\n     * @private\n     */\n    this.settings = Object.assign({}, options);\n\n    this.playbackCompatibility();\n    const self = this;\n    const callbacks = {\n      playingCb() {\n        self.emitter.emit('playing', []);\n      },\n      timeupdateCb() {\n        self.emitter.emit('timeupdate', []);\n      },\n      durationchangeCb() {\n        self.emitter.emit('durationchange', []);\n      },\n      canplayCb() {\n        self.emitter.emit('canplay', []);\n      },\n      endedCb() {\n        self.emitter.emit('ended', []);\n      },\n      pauseCb() {\n        self.emitter.emit('pause', []);\n      },\n      stoppedCb() {\n        self.emitter.emit('stopped', []);\n      },\n      playbackStoppedCb() {\n        self.emitter.emit('playbackstopped', []);\n        if (self.stopwatch) {\n          self.stopwatch.stop();\n        }\n      },\n      progressCb() {\n        self.emitter.emit('progress', []);\n      },\n      errorCb() {\n        self.emitter.emit('error', []);\n      },\n    };\n    /**\n     * Specific audio player.\n     * @type {WebAudioPlayer}\n     * @private\n     */\n    this.player = this.getPlayer(callbacks);\n\n    /**\n     * @type {Object}\n     * @private\n     */\n    this.emitter = ee({});\n\n    /**\n     * @type {Object}\n     * @private\n     */\n    this.stopwatch = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.audioLevel = 1;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.audioMuted = false;\n  }\n\n  /**\n   * Turn off all event listeners for this player.\n   */\n  resetEventListeners() {\n    allOff(this.emitter);\n  }\n\n  /**\n   * Add an event listener. Listens to events emitted from the player.\n   *\n   * @param {string} name - Name of the event.\n   * @param {Function} handler - Handler function to add.\n   */\n  addEventListener(name, handler) {\n    this.emitter.on(name, handler);\n  }\n\n  /**\n   * Remove an event listener of the player.\n   *\n   * @param {string} name - Name of the event.\n   * @param {Function} handler - Handler function to remove.\n   */\n  removeEventListener(name, handler) {\n    this.emitter.off(name, handler);\n  }\n\n  /**\n   * Check for mandatory browser compatibility.\n   * Logs detailed browser compatibilities related to for audio playback.\n   *\n   * @throws {Error} If no native wave or MP3 playback is available.\n   * @private\n   */\n  playbackCompatibility() {\n    // Detect audio playback capabilities.\n\n    // Detect HTML5 Audio playback.\n    // http://caniuse.com/#feat=audio\n    this.canUseAudio = Boolean(Audio);\n    console.log('Native HTML5 Audio playback capability:', this.canUseAudio);\n\n    if (!this.canUseAudio) {\n      throw new Error(\n        'Some form of audio playback capability is required',\n      );\n    }\n    if (this.canUseAudio) {\n      const audio = new Audio();\n      if (!(audio.canPlayType && audio.canPlayType instanceof Function)) {\n        throw new Error(\n          'Unable to detect audio playback capabilities',\n        );\n      }\n      const canPlayOggVorbis = audio.canPlayType(\n        'audio/ogg; codecs=\"vorbis\"',\n      ) !== '';\n      const canPlayOggOpus = audio.canPlayType(\n        'audio/ogg; codecs=\"opus\"',\n      ) !== '';\n      const canPlayWave = audio.canPlayType('audio/wav') !== '';\n      const canPlayMP3 = audio.canPlayType('audio/mpeg; codecs=\"mp3\"') !== '';\n      const canPlayAAC = audio.canPlayType(\n        'audio/mp4; codecs=\"mp4a.40.2\"',\n      ) !== '';\n      const canPlay3GPP = audio.canPlayType(\n        'audio/3gpp; codecs=\"samr\"',\n      ) !== '';\n\n      console.log('Native Vorbis audio in Ogg container playback capability:', canPlayOggVorbis);\n      console.log('Native Opus audio in Ogg container playback capability:', canPlayOggOpus);\n      console.log('Native PCM audio in Waveform Audio File Format (WAVE) playback capability:', canPlayWave);\n      console.log('Native MPEG Audio Layer 3 (MP3) playback capability:', canPlayMP3);\n      console.log('Native Low-Complexity AAC audio in MP4 container playback capability:', canPlayAAC);\n      console.log('Native AMR audio in 3GPP container playback capability:', canPlay3GPP);\n\n      if (!(canPlayWave || canPlayMP3)) {\n        throw new Error(\n          'Native Wave or MP3 playback is required',\n        );\n      }\n    }\n  }\n\n  /**\n   * Get a player object that performs audio compression, when available.\n   *\n   * Using the Media Stream Recording API for recording is the preferred\n   * solution. It allows recording compressed audio which makes it quicker to\n   * submit. If not available, use a default createScriptProcessor is used.\n   *\n   * @param {Function} callbacks - Callbacks to add to the chosen player.\n   * @private\n   */\n  getPlayer(callbacks) {\n    let player = null;\n\n    if (this.canUseAudio) {\n      // Use the recorder with MediaRecorder implementation.\n      player = new WebAudioPlayer(callbacks);\n    } else {\n      throw new Error('Unable to find a proper player.');\n    }\n    console.log('Player initialised.');\n    return player;\n  }\n\n  /**\n   * Preload audio from an URL.\n   *\n   * @param {string} url - The URL that contains the audio.\n   * @param {boolean} [preload=true] - Try preloading metadata and possible some audio. Set to false\n   * to not download anything until playing.\n   * @param {?Function} loadedCb - The callback that is invoked when the duration of the audio file\n   * is first known.\n   * @emits {Event} 'canplay' When the player is ready to play.\n   */\n  load(url, preload, loadedCb) {\n    this.reset();\n    this.player.load(url, preload, loadedCb);\n    this.audioLevel = 1;\n\n    // If preloading is disabled, the 'canplay' event won't be triggered.\n    // In that case, fire it manually.\n    if (!preload) {\n      this.emitter.emit('canplay', []);\n    }\n  }\n\n  /**\n   * Unload previously loaded audio. Stops the player and any stopwatch.\n   *\n   * @emits {Event} 'unloaded'\n   */\n  reset() {\n    this.stop();\n    this.player.reset();\n    this.emitter.emit('unloaded', []);\n  }\n\n  /**\n   * Start or continue playback of audio. Also starts the stopwatch at the given position.\n   *\n   * @param {?number} position - When position is given, start playing from this position (seconds).\n   */\n  play(position) {\n    if (this.player.isPlaying()) {\n      return;\n    }\n    this.player.play(position);\n    if (this.stopwatch) {\n      const time = Math.round(this.player.getCurrentTime() * 10);\n      this.stopwatch.value = time;\n      this.stopwatch.start();\n    }\n  }\n\n  /**\n   * Stop playback of audio. Stops and resets the stopwatch.\n   */\n  stop() {\n    if (this.stopwatch) {\n      this.stopwatch.reset();\n      this.stopwatch.stop();\n    }\n    this.player.stop();\n  }\n\n  /**\n   * Pause playback of audio. Stops the stopwatch.\n   */\n  pause() {\n    if (this.stopwatch) {\n      this.stopwatch.stop();\n    }\n    this.player.pause();\n  }\n\n  /**\n   * Toggle audio playback. Switch from playing to paused state and back.\n   */\n  togglePlayback() {\n    if (this.player.isPlaying()) {\n      this.pause();\n    } else {\n      this.play();\n    }\n  }\n\n  /**\n   * Start preloading audio.\n   */\n  preload() {\n    this.player.preload();\n  }\n\n  /**\n   * Start playing audio at the given offset. Corrects a percentage under 0 or above 100 to the\n   * respective values.\n   *\n   * @param {number} percentage - Start at this percentage (0..100) of the audio stream.\n   */\n  scrub(percentage) {\n    if (percentage < 0) {\n      this.player.scrub(0);\n    } else if (percentage > 100) {\n      this.player.scrub(100);\n    } else {\n      this.player.scrub(percentage);\n    }\n    if (this.stopwatch) {\n      this.stopwatch.value = Math.round(this.player.getCurrentTime() * 10);\n    }\n  }\n\n  /**\n   * Returns the percentage of which the buffer is filled.\n   *\n   * @returns {number} Percentage of buffer fill.\n   */\n  getBufferFill() {\n    return this.player.getBufferFill();\n  }\n\n  /**\n   * Returns the current playing time as offset in seconds from the start.\n   *\n   * @returns {number} Time in seconds as offset from the start.\n   */\n  getCurrentTime() {\n    return this.player.getCurrentTime();\n  }\n\n  /**\n   * Returns the total duration in seconds.\n   *\n   * @returns {number} Time in seconds of fragment duration.\n   */\n  getDuration() {\n    return this.player.getDuration();\n  }\n\n  /**\n   * Check if there is playback in progress.\n   *\n   * @returns {boolean} True if user is currently playing audio. False otherwise.\n   */\n  isPlaying() {\n    return this.player.isPlaying();\n  }\n\n  /**\n   * Returns ready state of the player.\n   *\n   * @returns {boolean} True when player is ready to start loading data or play. False when no audio\n   * is loaded or the player is preparing.\n   */\n  canPlay() {\n    return this.player.canPlay();\n  }\n\n  /**\n   * Set the playback rate of the audio. Values are used according to HTML5 Audio.\n   * Example values:\n   * *1.0 is normal speed.\n   * *0.5 is half speed (slower).\n   * *2.0 is double speed (faster).\n   * *-1.0 is backwards, normal speed.\n   * *-0.5 is backwards, half speed.\n   *\n   * @param {number} rate - Rate at which to change the audio playback.\n   */\n  setPlaybackRate(rate) {\n    this.player.setPlaybackRate(rate);\n  }\n\n  /**\n   * Get the playback rate of the current loaded audio.\n   *\n   * @returns {number} Playback rate of the audio.\n   */\n  getPlaybackRate() {\n    return this.player.getPlaybackRate();\n  }\n\n  /**\n   * Bind a stopwatch to sync with the playing and stopping functionality of the player.\n   *\n   * @param {Function} tickCb - Callback to invoke on every tick. A tick occurs once every 100 ms.\n   * @throws {Error} If tickCb is null.\n   * @returns {Stopwatch} New Stopwatch object.\n   */\n  bindStopwatch(tickCb) {\n    this.stopwatch = new Stopwatch((time) => {\n      const duration = this.getDuration() * 10 / this.player.sound.playbackRate;\n      if (time > duration) {\n        tickCb(duration);\n      } else {\n        tickCb(time);\n      }\n    });\n    return this.stopwatch;\n  }\n\n  /**\n   * Sets the audio level of the current loaded audio. Valid values are from 0 (0%) to 1 (100%).\n   *\n   * @param {number} volume - Volume value from 0 to 1.\n   */\n  setAudioVolume(volume) {\n    if (volume !== 0) {\n      this.audioMuted = false;\n    }\n    if (volume === 0) {\n      this.audioMuted = true;\n    }\n    this.player.setAudioVolume(volume);\n  }\n\n  /**\n   * Gets the audio level of the current loaded audio. Valid values are from 0 (0%) to 1 (100%).\n   *\n   * @returns {number} Volume level of the current loaded audio.\n   */\n  getAudioVolume() {\n    return this.player.getAudioVolume();\n  }\n\n  /**\n   * Toggle the current playing audio to be muted or not. If the audio will be muted, the current\n   * audio level is remembered and can be unmuted to continue at this same audio level.\n   */\n  toggleAudioMute() {\n    this.setAudioMute(!this.audioMuted);\n  }\n\n  /**\n   * Manually set the muted state of the current loaded audio.\n   *\n   * @param {boolean} shouldMute - Whether the audio should be muted or unmuted.\n   */\n  setAudioMute(shouldMute) {\n    if (shouldMute) {\n      this.audioLevel = this.getAudioVolume();\n      this.setAudioVolume(0);\n    } else {\n      this.setAudioVolume(this.audioLevel);\n    }\n  }\n\n  /**\n   * Return the muted state of the current loaded audio.\n   *\n   * @returns {boolean} The muted state of the current loaded audio.\n   */\n  isAudioMuted() {\n    return this.audioMuted;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/audio/audio-player.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 266,
    "kind": "class",
    "name": "AudioPlayer",
    "memberof": "src/audio/audio-player.js",
    "static": true,
    "longname": "src/audio/audio-player.js~AudioPlayer",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/audio/audio-player.js",
    "importStyle": "AudioPlayer",
    "description": "ITSLanguage AudioPlayer non-graphical component.",
    "lineNumber": 8,
    "interface": false
  },
  {
    "__docId__": 267,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#constructor",
    "access": "public",
    "description": "Construct an AudioPlayer for playing .wav or .mp3 files.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": true,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Override any of the default settings."
      }
    ],
    "emits": [
      {
        "types": [
          "Event"
        ],
        "description": "'playbackstopped' When playback has ended, been stopped or been paused."
      },
      {
        "types": [
          "Event"
        ],
        "description": "All events the HTML5 Audio also fires. {@link http://www.w3schools.com/tags/ref_av_dom.asp}"
      }
    ]
  },
  {
    "__docId__": 268,
    "kind": "member",
    "name": "settings",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#settings",
    "access": "private",
    "description": "",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 269,
    "kind": "member",
    "name": "player",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#player",
    "access": "private",
    "description": "Specific audio player.",
    "lineNumber": 65,
    "type": {
      "nullable": null,
      "types": [
        "WebAudioPlayer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 270,
    "kind": "member",
    "name": "emitter",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#emitter",
    "access": "private",
    "description": "",
    "lineNumber": 71,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 271,
    "kind": "member",
    "name": "stopwatch",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#stopwatch",
    "access": "private",
    "description": "",
    "lineNumber": 77,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 272,
    "kind": "member",
    "name": "audioLevel",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#audioLevel",
    "access": "private",
    "description": "",
    "lineNumber": 83,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 273,
    "kind": "member",
    "name": "audioMuted",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#audioMuted",
    "access": "private",
    "description": "",
    "lineNumber": 89,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 274,
    "kind": "method",
    "name": "resetEventListeners",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#resetEventListeners",
    "access": "public",
    "description": "Turn off all event listeners for this player.",
    "lineNumber": 95,
    "params": [],
    "return": null
  },
  {
    "__docId__": 275,
    "kind": "method",
    "name": "addEventListener",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#addEventListener",
    "access": "public",
    "description": "Add an event listener. Listens to events emitted from the player.",
    "lineNumber": 105,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the event."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "handler",
        "description": "Handler function to add."
      }
    ],
    "return": null
  },
  {
    "__docId__": 276,
    "kind": "method",
    "name": "removeEventListener",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#removeEventListener",
    "access": "public",
    "description": "Remove an event listener of the player.",
    "lineNumber": 115,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the event."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "handler",
        "description": "Handler function to remove."
      }
    ],
    "return": null
  },
  {
    "__docId__": 277,
    "kind": "method",
    "name": "playbackCompatibility",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#playbackCompatibility",
    "access": "private",
    "description": "Check for mandatory browser compatibility.\nLogs detailed browser compatibilities related to for audio playback.",
    "lineNumber": 126,
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If no native wave or MP3 playback is available."
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 278,
    "kind": "member",
    "name": "canUseAudio",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#canUseAudio",
    "access": "public",
    "description": null,
    "lineNumber": 131,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 279,
    "kind": "method",
    "name": "getPlayer",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#getPlayer",
    "access": "private",
    "description": "Get a player object that performs audio compression, when available.\n\nUsing the Media Stream Recording API for recording is the preferred\nsolution. It allows recording compressed audio which makes it quicker to\nsubmit. If not available, use a default createScriptProcessor is used.",
    "lineNumber": 186,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "callbacks",
        "description": "Callbacks to add to the chosen player."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 280,
    "kind": "method",
    "name": "load",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#load",
    "access": "public",
    "description": "Preload audio from an URL.",
    "lineNumber": 209,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "The URL that contains the audio."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "preload",
        "description": "Try preloading metadata and possible some audio. Set to false\nto not download anything until playing."
      },
      {
        "nullable": true,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "loadedCb",
        "description": "The callback that is invoked when the duration of the audio file\nis first known."
      }
    ],
    "emits": [
      {
        "types": [
          "Event"
        ],
        "description": "'canplay' When the player is ready to play."
      }
    ],
    "return": null
  },
  {
    "__docId__": 282,
    "kind": "method",
    "name": "reset",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#reset",
    "access": "public",
    "description": "Unload previously loaded audio. Stops the player and any stopwatch.",
    "lineNumber": 226,
    "emits": [
      {
        "types": [
          "Event"
        ],
        "description": "'unloaded'"
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 283,
    "kind": "method",
    "name": "play",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#play",
    "access": "public",
    "description": "Start or continue playback of audio. Also starts the stopwatch at the given position.",
    "lineNumber": 237,
    "params": [
      {
        "nullable": true,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "position",
        "description": "When position is given, start playing from this position (seconds)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 284,
    "kind": "method",
    "name": "stop",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#stop",
    "access": "public",
    "description": "Stop playback of audio. Stops and resets the stopwatch.",
    "lineNumber": 252,
    "params": [],
    "return": null
  },
  {
    "__docId__": 285,
    "kind": "method",
    "name": "pause",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#pause",
    "access": "public",
    "description": "Pause playback of audio. Stops the stopwatch.",
    "lineNumber": 263,
    "params": [],
    "return": null
  },
  {
    "__docId__": 286,
    "kind": "method",
    "name": "togglePlayback",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#togglePlayback",
    "access": "public",
    "description": "Toggle audio playback. Switch from playing to paused state and back.",
    "lineNumber": 273,
    "params": [],
    "return": null
  },
  {
    "__docId__": 287,
    "kind": "method",
    "name": "preload",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#preload",
    "access": "public",
    "description": "Start preloading audio.",
    "lineNumber": 284,
    "params": [],
    "return": null
  },
  {
    "__docId__": 288,
    "kind": "method",
    "name": "scrub",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#scrub",
    "access": "public",
    "description": "Start playing audio at the given offset. Corrects a percentage under 0 or above 100 to the\nrespective values.",
    "lineNumber": 294,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "percentage",
        "description": "Start at this percentage (0..100) of the audio stream."
      }
    ],
    "return": null
  },
  {
    "__docId__": 289,
    "kind": "method",
    "name": "getBufferFill",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#getBufferFill",
    "access": "public",
    "description": "Returns the percentage of which the buffer is filled.",
    "lineNumber": 312,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Percentage of buffer fill."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Percentage of buffer fill."
    },
    "params": []
  },
  {
    "__docId__": 290,
    "kind": "method",
    "name": "getCurrentTime",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#getCurrentTime",
    "access": "public",
    "description": "Returns the current playing time as offset in seconds from the start.",
    "lineNumber": 321,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Time in seconds as offset from the start."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Time in seconds as offset from the start."
    },
    "params": []
  },
  {
    "__docId__": 291,
    "kind": "method",
    "name": "getDuration",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#getDuration",
    "access": "public",
    "description": "Returns the total duration in seconds.",
    "lineNumber": 330,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Time in seconds of fragment duration."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Time in seconds of fragment duration."
    },
    "params": []
  },
  {
    "__docId__": 292,
    "kind": "method",
    "name": "isPlaying",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#isPlaying",
    "access": "public",
    "description": "Check if there is playback in progress.",
    "lineNumber": 339,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if user is currently playing audio. False otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if user is currently playing audio. False otherwise."
    },
    "params": []
  },
  {
    "__docId__": 293,
    "kind": "method",
    "name": "canPlay",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#canPlay",
    "access": "public",
    "description": "Returns ready state of the player.",
    "lineNumber": 349,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True when player is ready to start loading data or play. False when no audio\nis loaded or the player is preparing."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True when player is ready to start loading data or play. False when no audio\nis loaded or the player is preparing."
    },
    "params": []
  },
  {
    "__docId__": 294,
    "kind": "method",
    "name": "setPlaybackRate",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#setPlaybackRate",
    "access": "public",
    "description": "Set the playback rate of the audio. Values are used according to HTML5 Audio.\nExample values:\n*1.0 is normal speed.\n*0.5 is half speed (slower).\n*2.0 is double speed (faster).\n*-1.0 is backwards, normal speed.\n*-0.5 is backwards, half speed.",
    "lineNumber": 364,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "rate",
        "description": "Rate at which to change the audio playback."
      }
    ],
    "return": null
  },
  {
    "__docId__": 295,
    "kind": "method",
    "name": "getPlaybackRate",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#getPlaybackRate",
    "access": "public",
    "description": "Get the playback rate of the current loaded audio.",
    "lineNumber": 373,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Playback rate of the audio."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Playback rate of the audio."
    },
    "params": []
  },
  {
    "__docId__": 296,
    "kind": "method",
    "name": "bindStopwatch",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#bindStopwatch",
    "access": "public",
    "description": "Bind a stopwatch to sync with the playing and stopping functionality of the player.",
    "lineNumber": 384,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Stopwatch} New Stopwatch object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "tickCb",
        "description": "Callback to invoke on every tick. A tick occurs once every 100 ms."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Stopwatch"
      ],
      "spread": false,
      "description": "New Stopwatch object."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If tickCb is null."
      }
    ]
  },
  {
    "__docId__": 298,
    "kind": "method",
    "name": "setAudioVolume",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#setAudioVolume",
    "access": "public",
    "description": "Sets the audio level of the current loaded audio. Valid values are from 0 (0%) to 1 (100%).",
    "lineNumber": 401,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "volume",
        "description": "Volume value from 0 to 1."
      }
    ],
    "return": null
  },
  {
    "__docId__": 301,
    "kind": "method",
    "name": "getAudioVolume",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#getAudioVolume",
    "access": "public",
    "description": "Gets the audio level of the current loaded audio. Valid values are from 0 (0%) to 1 (100%).",
    "lineNumber": 416,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Volume level of the current loaded audio."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Volume level of the current loaded audio."
    },
    "params": []
  },
  {
    "__docId__": 302,
    "kind": "method",
    "name": "toggleAudioMute",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#toggleAudioMute",
    "access": "public",
    "description": "Toggle the current playing audio to be muted or not. If the audio will be muted, the current\naudio level is remembered and can be unmuted to continue at this same audio level.",
    "lineNumber": 424,
    "params": [],
    "return": null
  },
  {
    "__docId__": 303,
    "kind": "method",
    "name": "setAudioMute",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#setAudioMute",
    "access": "public",
    "description": "Manually set the muted state of the current loaded audio.",
    "lineNumber": 433,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "shouldMute",
        "description": "Whether the audio should be muted or unmuted."
      }
    ],
    "return": null
  },
  {
    "__docId__": 305,
    "kind": "method",
    "name": "isAudioMuted",
    "memberof": "src/audio/audio-player.js~AudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-player.js~AudioPlayer#isAudioMuted",
    "access": "public",
    "description": "Return the muted state of the current loaded audio.",
    "lineNumber": 447,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} The muted state of the current loaded audio."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "The muted state of the current loaded audio."
    },
    "params": []
  },
  {
    "__docId__": 306,
    "kind": "file",
    "name": "src/audio/audio-recorder.js",
    "content": "import allOff from 'event-emitter/all-off';\nimport ee from 'event-emitter';\nimport uuid from 'uuid';\nimport Stopwatch from './tools';\nimport WavePacker from './wave-packer';\nimport WebAudioRecorder from './web-audio-recorder';\n\n/**\n * Audio recording component.\n*/\n\nexport default class AudioRecorder {\n  /**\n   * ITSLanguage AudioRecorder.\n   *\n   * @param {?Object} options - Override any of the default settings.\n   *\n   */\n  constructor(options = {}) {\n    this.settings = Object.assign({}, options);\n\n    this.recordingCompatibility();\n\n    this.userMediaApproval = false;\n\n    /**\n     * The specific recorder type.\n     * @type {WebAudioRecorder|MediaRecorder}\n     * @private\n     */\n    this.recorder = null;\n\n    this.emitter = ee({});\n\n    this.stopwatch = null;\n\n    if (options.audioContext) {\n      this.audioContext = options.audioContext;\n    } else {\n      this.audioContext = AudioRecorder.createAudioContext();\n    }\n  }\n\n\n  /**\n   * Get the audio context or create one.\n   *\n   * @return {AudioContext} The AudioContext created will be returned.\n   */\n  static createAudioContext() {\n    if (!window.ItslAudioContext) {\n      window.AudioContext = window.AudioContext || window.webkitAudioContext;\n      window.ItslAudioContext = new window.AudioContext();\n    }\n    return window.ItslAudioContext;\n  }\n\n  /**\n   * Turn off all event listeners for this recorder.\n   */\n  removeAllEventListeners() {\n    allOff(this.emitter);\n  }\n\n  /**\n   * Add an event listener. Listens to events emitted from the recorder.\n   *\n   * @param {string} name - Name of the event.\n   * @param {Function} handler - Handler function to add.\n   */\n  addEventListener(name, handler) {\n    this.emitter.on(name, handler);\n  }\n\n  /**\n   * Remove an event listener of the recorder.\n   *\n   * @param {string} name - Name of the event.\n   * @param {Function} handler - Handler function to remove.\n   */\n  removeEventListener(name, handler) {\n    this.emitter.off(name, handler);\n  }\n\n  /**\n   * Fire an event.\n   *\n   * @param {string} name - Name of the event.\n   * @param {Object[]} args - Arguments.\n   * @private\n   */\n  fireEvent(name, args = []) {\n    this.emitter.emit(name, ...args);\n  }\n\n  /**\n   * Check if the user has already given permission to access the microphone.\n   *\n   * @returns {boolean} True if user has granted access to the microphone. False otherwise.\n   */\n  hasUserMediaApproval() {\n    return this.userMediaApproval || false;\n  }\n\n  /**\n   * Logs browser compatibility for audio recording.\n   * In case of compatibility issues, an error is thrown.\n   *\n   * @private\n   */\n  recordingCompatibility/* istanbul ignore next */() {\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/mediaDevices.getUserMedia\n    this.canMediaDevicesGetUserMedia = false;\n    if (navigator.mediaDevices) {\n      navigator.mediaDevices.getUserMedia = navigator.mediaDevices.getUserMedia\n        || navigator.mediaDevices.webkitGetUserMedia\n        || navigator.mediaDevices.mozGetUserMedia;\n      this.canMediaDevicesGetUserMedia = Boolean(navigator.mediaDevices.getUserMedia);\n    }\n    console.log('Native navigator.mediaDevices.getUserMedia API capability:', this.canMediaDevicesGetUserMedia);\n\n    if (!this.canGetUserMedia && !this.canMediaDevicesGetUserMedia) {\n      throw new Error(\n        'Some form of audio recording capability is required',\n      );\n    }\n\n    window.URL = window.URL || window.webkitURL;\n    const hasWindowURL = Boolean(window.URL);\n    console.log('Native window.URL capability:', hasWindowURL);\n    if (!hasWindowURL) {\n      throw new Error(\n        'No window.URL blob conversion capabilities',\n      );\n    }\n  }\n\n  /**\n   * Request microphone access.\n   *\n   * Calling this function may result in thrown exceptions when browser\n   * doesn't support provide live audio input.\n   *\n   * @throws {Error} If no live audio input is available or permitted.\n   * @returns {Promise} - A promise that resolves a MediaStream object.\n   *  If the user denies permission, or matching media is not available, then the\n   *  promise is rejected with PermissionDeniedError or NotFoundError respectively.\n   */\n  requestUserMedia() {\n    const readyForStream = (stream) => {\n      // Modify state of userMediaApproval now access is granted.\n      this.userMediaApproval = true;\n\n      const micInputGain = this.startUserMedia(stream);\n      this.fireEvent('ready', [this.audioContext, micInputGain]);\n    };\n\n    const userCanceled = (error) => {\n      console.error(error);\n      throw new Error('No live audio input available or permitted');\n    };\n\n    return navigator.mediaDevices.getUserMedia({ audio: true })\n      .then(readyForStream)\n      .catch(userCanceled);\n  }\n\n  /**\n   * Audio access was granted, start analysing.\n   *\n   * @param {MediaStream} stream - Media Stream.\n   * @private\n   */\n  startUserMedia(stream) {\n    // Creates an audio node from the microphone incoming stream.\n    const micInput = this.audioContext.createMediaStreamSource(stream);\n\n    // This is a workaround for a bug in Firefox that would otherwise lead to\n    // the sound input stopping after ~5 seconds.\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=934512\n    // the important thing is to save a reference to the MediaStreamAudioSourceNode\n    this.micInput = micInput;\n\n    // Create a gain node\n    const micInputGain = this.audioContext.createGain();\n    // Connect the microphone source to a gain node.\n    micInput.connect(micInputGain);\n\n    this.recorder = this.getBestRecorder(micInputGain);\n\n    return micInputGain;\n  }\n\n  /**\n   * Get a recorder object that performs audio compression, when available.\n   *\n   * Using the Media Stream Recording API for recording is the preferred\n   * solution. It allows recording compressed audio which makes it quicker to\n   * submit. If not available, use a default createScriptProcessor is used.\n   *\n   * @param {GainNode} micInputGain - The GainNode to analyze.\n   * @private\n   */\n  getBestRecorder(micInputGain) {\n    return new WebAudioRecorder(micInputGain, this.audioContext, (data) => {\n      this.streamCallback(data);\n    }, new WavePacker(), false);\n  }\n\n  /**\n   * Called when a chunk of audio becomes available.\n   *\n   * @param {ArrayBuffer} chunk - A chunk of audio (Int16 formatted).\n   */\n  streamCallback(chunk) {\n    this.fireEvent('dataavailable', [chunk]);\n  }\n\n  /**\n   * Throw an error if the user is not yet logged in.\n   *\n   * @returns {boolean} True when permission was already granted. False otherwise.\n   * @private\n   */\n  requireGetUserMedia() {\n    if (this.recorder) {\n      return true;\n    }\n    console.log('Requesting getUserMedia permission first.');\n    this.requestUserMedia();\n    return false;\n  }\n\n  /**\n   * Set a new recording session id.\n   *\n   * @param {number} id - When defined, stick this id to the recorded blob.\n   *\n   * @returns {number} The id that was given or a unique generated one.\n   */\n  startRecordingSession(id) {\n    // Generate a uuid to remember this recording by (locally).\n    const newUuid = id === undefined ? uuid.v4() : id;\n    this.activeRecordingId = newUuid;\n    return newUuid;\n  }\n\n  /**\n   * Start recording microphone input until stopped. By default the actual recording will start\n   * a small delay of 100ms. Set disableDelay to true to disable this delay.\n   *\n   * @param {boolean} disableDelay - If set to true it will disable the delay before the actual\n   * recording starts.\n   * @emits {Event} 'recording' With arguments: [recording ID].\n   */\n  record(disableDelay = false) {\n    if (!this.requireGetUserMedia()) {\n      return;\n    }\n\n    if (this.isRecording()) {\n      throw new Error('Already recording, stop recording first.');\n    }\n\n    const delay = disableDelay ? 0 : 100;\n\n    window.setTimeout(() => {\n      this.audioContext.resume();\n\n      this.recorder.record();\n      if (this.stopwatch) {\n        this.stopwatch.value = 0;\n        this.stopwatch.start();\n      }\n\n      if (!this.activeRecordingId) {\n        this.startRecordingSession();\n      }\n      console.log(`Recording as id: ${this.activeRecordingId}`);\n\n      this.fireEvent('recording', [this.activeRecordingId]);\n    }, delay);\n  }\n\n  /**\n   * Stop recording microphone input.\n   *\n   * @param {boolean} [forced=false] - Set whether to force the microphone to stop recording or let\n   * it end normally.\n   * @emits {Event} 'recorded' With arguments: [recording ID, audio Blob, forced].\n   */\n  stop(forced) {\n    if (!this.recorder.isPaused() && !this.recorder.isRecording()) {\n      return;\n    }\n    this.recorder.stop();\n    if (this.stopwatch) {\n      this.stopwatch.stop();\n    }\n    console.log(`Stopped recording for id: ${this.activeRecordingId}`);\n\n    const self = this;\n    this.recorder.getEncodedAudio((blob) => {\n      console.log(`Received encoded audio of type: ${blob.type}`);\n      // Allow direct playback from local blob.\n      self.fireEvent('recorded', [self.activeRecordingId, blob, Boolean(forced)]);\n    });\n  }\n\n  pause() {\n    if (!this.recorder.isPaused() && !this.recorder.isRecording()) {\n      return;\n    }\n    this.recorder.pause();\n    if (this.stopwatch) {\n      this.stopwatch.stop();\n    }\n    console.log(`paused recording for id: ${this.activeRecordingId}`);\n    this.fireEvent('paused', [this.activeRecordingId]);\n  }\n\n  /**\n   * Check if there is a recording in progress.\n   *\n   * @returns {boolean} True if user is currently recording audio. False` otherwise.\n   */\n  isRecording() {\n    if (!this.recorder) {\n      return false;\n    }\n    return this.recorder.isRecording();\n  }\n\n  /**\n   * Check if the recorder is in paused state.\n   *\n   * @returns {boolean} True if the recorder is paused. False` otherwise.\n   */\n  isPaused() {\n    if (!this.recorder) {\n      return false;\n    }\n    return this.recorder.isPaused();\n  }\n\n  /**\n   * Toggle audio playback. Switch from playing to paused state and back.\n   */\n  toggleRecording() {\n    if (this.isRecording()) {\n      this.stop();\n    } else {\n      this.record();\n    }\n  }\n\n  /**\n   * Get the recorded audio specifications.\n   *\n   * @returns {Object} Containing audioFormat and audioParameters describing the format.\n   */\n  getAudioSpecs() {\n    return this.recorder.getAudioSpecs();\n  }\n\n  /**\n   * Bind a stopwatch to sync with the playing and stopping functionality of the recorder.\n   *\n   * @param {Function} tickCb - Callback to invoke on every tick. A tick occurs once every 100 ms.\n   * @throws {Error} If tickCb is null.\n   * @returns {Stopwatch} New Stopwatch object.\n   */\n  bindStopwatch(tickCb) {\n    this.stopwatch = new Stopwatch(tickCb);\n    return this.stopwatch;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/audio/audio-recorder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 307,
    "kind": "class",
    "name": "AudioRecorder",
    "memberof": "src/audio/audio-recorder.js",
    "static": true,
    "longname": "src/audio/audio-recorder.js~AudioRecorder",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/audio/audio-recorder.js",
    "importStyle": "AudioRecorder",
    "description": "Audio recording component.",
    "lineNumber": 12,
    "interface": false
  },
  {
    "__docId__": 308,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#constructor",
    "access": "public",
    "description": "ITSLanguage AudioRecorder.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": true,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Override any of the default settings."
      }
    ]
  },
  {
    "__docId__": 309,
    "kind": "member",
    "name": "settings",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#settings",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 310,
    "kind": "member",
    "name": "userMediaApproval",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#userMediaApproval",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 311,
    "kind": "member",
    "name": "recorder",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#recorder",
    "access": "private",
    "description": "The specific recorder type.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "WebAudioRecorder",
        "MediaRecorder"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 312,
    "kind": "member",
    "name": "emitter",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#emitter",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 313,
    "kind": "member",
    "name": "stopwatch",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#stopwatch",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 314,
    "kind": "member",
    "name": "audioContext",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#audioContext",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 316,
    "kind": "method",
    "name": "createAudioContext",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/audio/audio-recorder.js~AudioRecorder.createAudioContext",
    "access": "public",
    "description": "Get the audio context or create one.",
    "lineNumber": 50,
    "return": {
      "nullable": null,
      "types": [
        "AudioContext"
      ],
      "spread": false,
      "description": "The AudioContext created will be returned."
    },
    "params": []
  },
  {
    "__docId__": 317,
    "kind": "method",
    "name": "removeAllEventListeners",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#removeAllEventListeners",
    "access": "public",
    "description": "Turn off all event listeners for this recorder.",
    "lineNumber": 61,
    "params": [],
    "return": null
  },
  {
    "__docId__": 318,
    "kind": "method",
    "name": "addEventListener",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#addEventListener",
    "access": "public",
    "description": "Add an event listener. Listens to events emitted from the recorder.",
    "lineNumber": 71,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the event."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "handler",
        "description": "Handler function to add."
      }
    ],
    "return": null
  },
  {
    "__docId__": 319,
    "kind": "method",
    "name": "removeEventListener",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#removeEventListener",
    "access": "public",
    "description": "Remove an event listener of the recorder.",
    "lineNumber": 81,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the event."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "handler",
        "description": "Handler function to remove."
      }
    ],
    "return": null
  },
  {
    "__docId__": 320,
    "kind": "method",
    "name": "fireEvent",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#fireEvent",
    "access": "private",
    "description": "Fire an event.",
    "lineNumber": 92,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the event."
      },
      {
        "nullable": null,
        "types": [
          "Object[]"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": "Arguments."
      }
    ],
    "return": null
  },
  {
    "__docId__": 321,
    "kind": "method",
    "name": "hasUserMediaApproval",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#hasUserMediaApproval",
    "access": "public",
    "description": "Check if the user has already given permission to access the microphone.",
    "lineNumber": 101,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if user has granted access to the microphone. False otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if user has granted access to the microphone. False otherwise."
    },
    "params": []
  },
  {
    "__docId__": 322,
    "kind": "method",
    "name": "recordingCompatibility",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#recordingCompatibility",
    "access": "private",
    "description": "Logs browser compatibility for audio recording.\nIn case of compatibility issues, an error is thrown.",
    "lineNumber": 111,
    "params": [],
    "return": null
  },
  {
    "__docId__": 323,
    "kind": "member",
    "name": "canMediaDevicesGetUserMedia",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#canMediaDevicesGetUserMedia",
    "access": "public",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 325,
    "kind": "method",
    "name": "requestUserMedia",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#requestUserMedia",
    "access": "public",
    "description": "Request microphone access.\n\nCalling this function may result in thrown exceptions when browser\ndoesn't support provide live audio input.",
    "lineNumber": 149,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} - A promise that resolves a MediaStream object.\n If the user denies permission, or matching media is not available, then the\n promise is rejected with PermissionDeniedError or NotFoundError respectively."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "A promise that resolves a MediaStream object.\n If the user denies permission, or matching media is not available, then the\n promise is rejected with PermissionDeniedError or NotFoundError respectively."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If no live audio input is available or permitted."
      }
    ],
    "params": []
  },
  {
    "__docId__": 327,
    "kind": "method",
    "name": "startUserMedia",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#startUserMedia",
    "access": "private",
    "description": "Audio access was granted, start analysing.",
    "lineNumber": 174,
    "params": [
      {
        "nullable": null,
        "types": [
          "MediaStream"
        ],
        "spread": false,
        "optional": false,
        "name": "stream",
        "description": "Media Stream."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 328,
    "kind": "member",
    "name": "micInput",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#micInput",
    "access": "public",
    "description": null,
    "lineNumber": 182,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 330,
    "kind": "method",
    "name": "getBestRecorder",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#getBestRecorder",
    "access": "private",
    "description": "Get a recorder object that performs audio compression, when available.\n\nUsing the Media Stream Recording API for recording is the preferred\nsolution. It allows recording compressed audio which makes it quicker to\nsubmit. If not available, use a default createScriptProcessor is used.",
    "lineNumber": 204,
    "params": [
      {
        "nullable": null,
        "types": [
          "GainNode"
        ],
        "spread": false,
        "optional": false,
        "name": "micInputGain",
        "description": "The GainNode to analyze."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 331,
    "kind": "method",
    "name": "streamCallback",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#streamCallback",
    "access": "public",
    "description": "Called when a chunk of audio becomes available.",
    "lineNumber": 215,
    "params": [
      {
        "nullable": null,
        "types": [
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "chunk",
        "description": "A chunk of audio (Int16 formatted)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 332,
    "kind": "method",
    "name": "requireGetUserMedia",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#requireGetUserMedia",
    "access": "private",
    "description": "Throw an error if the user is not yet logged in.",
    "lineNumber": 225,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True when permission was already granted. False otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True when permission was already granted. False otherwise."
    },
    "params": []
  },
  {
    "__docId__": 333,
    "kind": "method",
    "name": "startRecordingSession",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#startRecordingSession",
    "access": "public",
    "description": "Set a new recording session id.",
    "lineNumber": 241,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} The id that was given or a unique generated one."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "When defined, stick this id to the recorded blob."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The id that was given or a unique generated one."
    }
  },
  {
    "__docId__": 334,
    "kind": "member",
    "name": "activeRecordingId",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#activeRecordingId",
    "access": "public",
    "description": null,
    "lineNumber": 244,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 335,
    "kind": "method",
    "name": "record",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#record",
    "access": "public",
    "description": "Start recording microphone input until stopped. By default the actual recording will start\na small delay of 100ms. Set disableDelay to true to disable this delay.",
    "lineNumber": 256,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "disableDelay",
        "description": "If set to true it will disable the delay before the actual\nrecording starts."
      }
    ],
    "emits": [
      {
        "types": [
          "Event"
        ],
        "description": "'recording' With arguments: [recording ID]."
      }
    ],
    "return": null
  },
  {
    "__docId__": 336,
    "kind": "method",
    "name": "stop",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#stop",
    "access": "public",
    "description": "Stop recording microphone input.",
    "lineNumber": 292,
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "forced",
        "description": "Set whether to force the microphone to stop recording or let\nit end normally."
      }
    ],
    "emits": [
      {
        "types": [
          "Event"
        ],
        "description": "'recorded' With arguments: [recording ID, audio Blob, forced]."
      }
    ],
    "return": null
  },
  {
    "__docId__": 337,
    "kind": "method",
    "name": "pause",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#pause",
    "access": "public",
    "description": null,
    "lineNumber": 310,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 338,
    "kind": "method",
    "name": "isRecording",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#isRecording",
    "access": "public",
    "description": "Check if there is a recording in progress.",
    "lineNumber": 327,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if user is currently recording audio. False` otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if user is currently recording audio. False` otherwise."
    },
    "params": []
  },
  {
    "__docId__": 339,
    "kind": "method",
    "name": "isPaused",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#isPaused",
    "access": "public",
    "description": "Check if the recorder is in paused state.",
    "lineNumber": 339,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True if the recorder is paused. False` otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if the recorder is paused. False` otherwise."
    },
    "params": []
  },
  {
    "__docId__": 340,
    "kind": "method",
    "name": "toggleRecording",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#toggleRecording",
    "access": "public",
    "description": "Toggle audio playback. Switch from playing to paused state and back.",
    "lineNumber": 349,
    "params": [],
    "return": null
  },
  {
    "__docId__": 341,
    "kind": "method",
    "name": "getAudioSpecs",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#getAudioSpecs",
    "access": "public",
    "description": "Get the recorded audio specifications.",
    "lineNumber": 362,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} Containing audioFormat and audioParameters describing the format."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Containing audioFormat and audioParameters describing the format."
    },
    "params": []
  },
  {
    "__docId__": 342,
    "kind": "method",
    "name": "bindStopwatch",
    "memberof": "src/audio/audio-recorder.js~AudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-recorder.js~AudioRecorder#bindStopwatch",
    "access": "public",
    "description": "Bind a stopwatch to sync with the playing and stopping functionality of the recorder.",
    "lineNumber": 373,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Stopwatch} New Stopwatch object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "tickCb",
        "description": "Callback to invoke on every tick. A tick occurs once every 100 ms."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Stopwatch"
      ],
      "spread": false,
      "description": "New Stopwatch object."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If tickCb is null."
      }
    ]
  },
  {
    "__docId__": 344,
    "kind": "file",
    "name": "src/audio/audio-tools.js",
    "content": "/**\n * ITSLanguage Javascript Audio tools.\n * @overview This is part of the ITSLanguage Javascript SDK to perform audio related functions.\n * @copyright (c) 2014 ITSLanguage\n * @license MIT\n * @author d-centralize\n */\n\nimport pcm from 'pcmjs';\n\n\n/**\n * Generate a dummy Wave file for testing purposes.\n *\n * @param {number} duration - Length of audio in seconds.\n * @returns {string} A new URL containing the Wave file.\n */\nexport function generateWaveSample(duration) {\n  const effect = [];\n  const sampleRate = 22000;\n  const loops = duration * sampleRate;\n  for (let i = 0; i < loops; i += 1) {\n    effect[i] = 64 + Math.round(\n      32 * (Math.cos(i * i / 2000) + Math.sin(i * i / 4000)),\n    );\n  }\n  // eslint-disable-next-line new-cap\n  const wave = new pcm({ channels: 1, rate: 22000, depth: 8 }).toWav(effect);\n  return wave.encode();\n}\n\n\nexport default class VolumeMeter {\n  /**\n   * Represents a volume meter.\n   *\n   * @param {AudioContext} audioContext - The WebAudio context.\n   * @param {MediaStream} inputStream - The MediaStream to analyze.\n   */\n  constructor(audioContext, inputStream) {\n    this.audioContext = audioContext;\n    this.stream = inputStream;\n    this.willAnimate = true;\n  }\n\n\n  /**\n   * Start analysing the audio stream and provide updates to the specified callback function.\n   *\n   * @param {Function} callback - This function is called when there's a new volume reading is\n   * available. First parameter is the volume.\n   * @param {?Array} args - Optional array of parameters to pass to the callback after the volume\n   * parameter.\n   */\n  getVolumeIndication(callback, args) {\n    if (!callback) {\n      throw new Error('Callback parameter unspecified.');\n    }\n\n    let callbackArray;\n\n    // Convert single callback to Array of callbacks\n    if (!(callback instanceof Array)) {\n      callbackArray = [callback];\n    } else {\n      callbackArray = [...callback];\n    }\n\n    this.volumeIndicationCallback = callbackArray;\n    this.volumeIndicationCallbackArgs = args || [];\n\n    this.analyserNode = this.audioContext.createAnalyser();\n    this.analyserNode.fftSize = 2048;\n    this.stream.connect(this.analyserNode);\n\n    this.updateAnalysers();\n  }\n\n  /**\n   * Get average volume from a list of frequency amplitudes.\n   *\n   * @param {Array<number>} amplitudes - Array with frequency amplitudes.\n   * @returns {number} - The average volume\n   * @private\n   */\n  static getAverageVolume(amplitudes = []) {\n    return (\n      amplitudes.reduce((sum, amplitude) => sum + amplitude) / amplitudes.length\n    );\n  }\n\n  /**\n   * Calculate the volume, inform listeners by executing the callback.\n   * Repeat indefinitely.\n   */\n  updateAnalysers() {\n    const { volumeIndicationCallback, volumeIndicationCallbackArgs, analyserNode } = this;\n    const volumeMeter = this;\n    let skippedCallbacks = 0;\n    let lastVolume = -1;\n\n    function animloop() {\n      /* The Window.requestAnimationFrame() method tells the\n       * browser that you wish to perform an animation and\n       * requests that the browser call a specified function to\n       * update an animation before the next repaint. The method\n       * takes as an argument a callback to be invoked before\n       * the repaint.\n       */\n      const requestAnimationFrame = window.requestAnimationFrame\n        || window.mozRequestAnimationFrame\n        || window.webkitRequestAnimationFrame\n        || window.msRequestAnimationFrame;\n\n      const freqByteData = new Uint8Array(analyserNode.frequencyBinCount);\n\n      analyserNode.getByteFrequencyData(freqByteData);\n      let averageVolume = VolumeMeter.getAverageVolume(freqByteData);\n\n      if (volumeMeter.willAnimate) {\n        requestAnimationFrame(animloop);\n      } else {\n        // Stop animating, provide callback with zero volume so the\n        // meter doesn't appear to be stuck at the last volume level.\n        averageVolume = 0;\n      }\n\n      // Callback only on substantial changes.\n      const minDiff = 1;\n      if (parseInt(averageVolume, 10) >= lastVolume - minDiff\n        && parseInt(averageVolume, 10) <= lastVolume + minDiff) {\n        // console.log('Skip same average: ' + lastVolume);\n        return true;\n      }\n      // console.log('Got new volume: ' + parseInt(averageVolume) +\n      // ' (old: ' + lastVolume + ')');\n      lastVolume = parseInt(averageVolume, 10);\n\n      const args = [averageVolume].concat(volumeIndicationCallbackArgs);\n      // Fire all callbacks.\n      volumeIndicationCallback.forEach((cb) => {\n        // This kludge prevents firing an averageVolume of zero\n        // right away. The buffer probably needs filling before useful\n        // values become available. 5 seems to be the magic number.\n        if (skippedCallbacks < 5) {\n          skippedCallbacks += 1;\n          return true;\n        }\n        return cb(args);\n      });\n\n      return true;\n    }\n\n    animloop();\n  }\n\n  /**\n   * Stop calculating the volume.\n   */\n  stopAnalyser() {\n    this.willAnimate = false;\n  }\n\n  /**\n   * Start calculating the volume.\n   */\n  resumeAnalyser() {\n    this.willAnimate = true;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/audio/audio-tools.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 345,
    "kind": "function",
    "name": "generateWaveSample",
    "memberof": "src/audio/audio-tools.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/audio/audio-tools.js~generateWaveSample",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/audio/audio-tools.js",
    "importStyle": "{generateWaveSample}",
    "description": "Generate a dummy Wave file for testing purposes.",
    "lineNumber": 18,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} A new URL containing the Wave file."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "duration",
        "description": "Length of audio in seconds."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "A new URL containing the Wave file."
    }
  },
  {
    "__docId__": 346,
    "kind": "class",
    "name": "VolumeMeter",
    "memberof": "src/audio/audio-tools.js",
    "static": true,
    "longname": "src/audio/audio-tools.js~VolumeMeter",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/audio/audio-tools.js",
    "importStyle": "VolumeMeter",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 347,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#constructor",
    "access": "public",
    "description": "Represents a volume meter.",
    "lineNumber": 40,
    "params": [
      {
        "nullable": null,
        "types": [
          "AudioContext"
        ],
        "spread": false,
        "optional": false,
        "name": "audioContext",
        "description": "The WebAudio context."
      },
      {
        "nullable": null,
        "types": [
          "MediaStream"
        ],
        "spread": false,
        "optional": false,
        "name": "inputStream",
        "description": "The MediaStream to analyze."
      }
    ]
  },
  {
    "__docId__": 348,
    "kind": "member",
    "name": "audioContext",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#audioContext",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 349,
    "kind": "member",
    "name": "stream",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#stream",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 350,
    "kind": "member",
    "name": "willAnimate",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#willAnimate",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 351,
    "kind": "method",
    "name": "getVolumeIndication",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#getVolumeIndication",
    "access": "public",
    "description": "Start analysing the audio stream and provide updates to the specified callback function.",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "This function is called when there's a new volume reading is\navailable. First parameter is the volume."
      },
      {
        "nullable": true,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": "Optional array of parameters to pass to the callback after the volume\nparameter."
      }
    ],
    "return": null
  },
  {
    "__docId__": 352,
    "kind": "member",
    "name": "volumeIndicationCallback",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#volumeIndicationCallback",
    "access": "public",
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 353,
    "kind": "member",
    "name": "volumeIndicationCallbackArgs",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#volumeIndicationCallbackArgs",
    "access": "public",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 354,
    "kind": "member",
    "name": "analyserNode",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#analyserNode",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 355,
    "kind": "method",
    "name": "getAverageVolume",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/audio/audio-tools.js~VolumeMeter.getAverageVolume",
    "access": "private",
    "description": "Get average volume from a list of frequency amplitudes.",
    "lineNumber": 86,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} - The average volume"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<number>"
        ],
        "spread": false,
        "optional": false,
        "name": "amplitudes",
        "description": "Array with frequency amplitudes."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The average volume"
    }
  },
  {
    "__docId__": 356,
    "kind": "method",
    "name": "updateAnalysers",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#updateAnalysers",
    "access": "public",
    "description": "Calculate the volume, inform listeners by executing the callback.\nRepeat indefinitely.",
    "lineNumber": 96,
    "params": [],
    "return": null
  },
  {
    "__docId__": 357,
    "kind": "method",
    "name": "stopAnalyser",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#stopAnalyser",
    "access": "public",
    "description": "Stop calculating the volume.",
    "lineNumber": 161,
    "params": [],
    "return": null
  },
  {
    "__docId__": 359,
    "kind": "method",
    "name": "resumeAnalyser",
    "memberof": "src/audio/audio-tools.js~VolumeMeter",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/audio-tools.js~VolumeMeter#resumeAnalyser",
    "access": "public",
    "description": "Start calculating the volume.",
    "lineNumber": 168,
    "params": [],
    "return": null
  },
  {
    "__docId__": 361,
    "kind": "file",
    "name": "src/audio/media-recorder.js",
    "content": "/*\n * Use the Media Stream Recording API for recording and encoding. Ogg Opus\n * (audio/ogg) is the preferred output format.\n *\n * The Media Stream Recording API is W3C standard in the making:\n * https://dvcs.w3.org/hg/dap/raw-file/tip/media-stream-capture/RecordingProposal.html\n *\n * Currently only supported in Firefox. There's a standards author working for\n * Microsoft which hints wide adoption in the future.\n *\n * Encoder only supports 48k/16k mono audio channel.\n * http://dxr.mozilla.org/mozilla-central/source/content/media/MediaRecorder.cpp\n * https://wiki.mozilla.org/Gecko:MediaRecorder\n *\n */\n/**\n * @private\n */\nexport default class MediaRecorder {\n  /**\n   * MediaRecorder.\n   *\n   * @param {MediaStream} mediaStream - The MediaStream to analyze.\n   */\n  constructor(mediaStream) {\n    const self = this;\n    this.mediaRecorder = new window.MediaRecorder(mediaStream);\n    this.mediaRecorder.ondataavailable = (event) => {\n      self.recordedBlob = new Blob([event.data], {\n        type: 'audio/ogg',\n      });\n      console.log(`Recorded audio/ogg Blob size: ${self.recordedBlob.size}`);\n      if (self.callback) {\n        self.callback(self.recordedBlob);\n        self.callback = null;\n      }\n    };\n  }\n\n  /**\n   * Start recording audio.\n   */\n  record() {\n    this.recordedBlob = null;\n    this.callback = null;\n    this.mediaRecorder.start();\n  }\n\n  /**\n   * Is audio recording in progress.\n   *\n   * @returns {boolean} True when recording. False otherwise.\n   */\n  isRecording() {\n    return this.mediaRecorder.state === 'recording';\n  }\n\n  /**\n   * Stop recording audio.\n   */\n  stop() {\n    if (this.isRecording()) {\n      // Calling `stop()` throws a dataavailable event.\n      this.mediaRecorder.stop();\n    }\n  }\n\n  /**\n   * Request encoded audio to be returned through callback.\n   *\n   * @param {Function} callback - The callback to use when returning the audio as a blob in Ogg Opus\n   * format.\n   */\n  getEncodedAudio(callback) {\n    if (this.recordedBlob) {\n      // Data already available, return right away.\n      callback(this.recordedBlob);\n      return;\n    }\n    // Callback will trigger later when audio is ready.\n    this.callback = callback;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/audio/media-recorder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 362,
    "kind": "class",
    "name": "MediaRecorder",
    "memberof": "src/audio/media-recorder.js",
    "static": true,
    "longname": "src/audio/media-recorder.js~MediaRecorder",
    "access": "private",
    "export": true,
    "importPath": "@itslanguage/sdk/audio/media-recorder.js",
    "importStyle": "MediaRecorder",
    "description": "",
    "lineNumber": 19,
    "interface": false
  },
  {
    "__docId__": 363,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/audio/media-recorder.js~MediaRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/media-recorder.js~MediaRecorder#constructor",
    "access": "public",
    "description": "MediaRecorder.",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "MediaStream"
        ],
        "spread": false,
        "optional": false,
        "name": "mediaStream",
        "description": "The MediaStream to analyze."
      }
    ]
  },
  {
    "__docId__": 364,
    "kind": "member",
    "name": "mediaRecorder",
    "memberof": "src/audio/media-recorder.js~MediaRecorder",
    "static": false,
    "longname": "src/audio/media-recorder.js~MediaRecorder#mediaRecorder",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 365,
    "kind": "method",
    "name": "record",
    "memberof": "src/audio/media-recorder.js~MediaRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/media-recorder.js~MediaRecorder#record",
    "access": "public",
    "description": "Start recording audio.",
    "lineNumber": 43,
    "params": [],
    "return": null
  },
  {
    "__docId__": 366,
    "kind": "member",
    "name": "recordedBlob",
    "memberof": "src/audio/media-recorder.js~MediaRecorder",
    "static": false,
    "longname": "src/audio/media-recorder.js~MediaRecorder#recordedBlob",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 367,
    "kind": "member",
    "name": "callback",
    "memberof": "src/audio/media-recorder.js~MediaRecorder",
    "static": false,
    "longname": "src/audio/media-recorder.js~MediaRecorder#callback",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 368,
    "kind": "method",
    "name": "isRecording",
    "memberof": "src/audio/media-recorder.js~MediaRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/media-recorder.js~MediaRecorder#isRecording",
    "access": "public",
    "description": "Is audio recording in progress.",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True when recording. False otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True when recording. False otherwise."
    },
    "params": []
  },
  {
    "__docId__": 369,
    "kind": "method",
    "name": "stop",
    "memberof": "src/audio/media-recorder.js~MediaRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/media-recorder.js~MediaRecorder#stop",
    "access": "public",
    "description": "Stop recording audio.",
    "lineNumber": 61,
    "params": [],
    "return": null
  },
  {
    "__docId__": 370,
    "kind": "method",
    "name": "getEncodedAudio",
    "memberof": "src/audio/media-recorder.js~MediaRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/media-recorder.js~MediaRecorder#getEncodedAudio",
    "access": "public",
    "description": "Request encoded audio to be returned through callback.",
    "lineNumber": 74,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback to use when returning the audio as a blob in Ogg Opus\nformat."
      }
    ],
    "return": null
  },
  {
    "__docId__": 372,
    "kind": "file",
    "name": "src/audio/tools.js",
    "content": "/**\n * ITSLanguage Javascript helper tools.\n * @overview This is part of the ITSLanguage Javascript SDK to perform helper functions.\n * @copyright (c) 2014 ITSLanguage\n * @license MIT\n * @author d-centralize\n */\n\nconst ee = require('event-emitter');\n\n/**\n * A simple stopwatch that ticks every 100 ms. It can be bound to an {@link AudioPlayer} or\n * {@link AudioRecorder} which binds the stop and playing functionality to the stopping and starting\n * of the Watch. It can also be listened to by other entities.\n *\n * @experimental When binding to an Audio Recorder, the stopwatch is not always synced properly. A\n * difference of 0.1s or 0.2s too high may occur when counting. When binding to an Audio Player\n * however, the timer will sync properly and show the correct duration of the loaded audio file.\n */\nexport default class Stopwatch {\n  /**\n   * @param {Function} tickCb - The callback that is invoked on every tick (every 100ms).\n   * @throws {Error} If tickCb is missing.\n   */\n  constructor(tickCb) {\n    if (!tickCb) {\n      throw new Error('tickCb parameter required');\n    }\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.interval = null;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.value = 0;\n\n    /**\n     * @type {Function}\n     * @private\n     */\n    this.tickCb = tickCb;\n\n    /**\n     * @type {Object}\n     * @private\n     */\n    this.emitter = ee({});\n  }\n\n  /**\n   * Start counting and tick every 100 ms.\n   */\n  start() {\n    console.debug('Start counting');\n    // Tick every 100ms (0.1s)\n    const self = this;\n    this.interval = setInterval(() => {\n      self.update();\n    }, 100);\n  }\n\n  /**\n   * Stop counting.\n   */\n  stop() {\n    console.debug('Stop counting');\n    clearInterval(this.interval);\n    this.tick();\n    this.interval = null;\n  }\n\n  /**\n   * Reset count to 0.\n   */\n  reset() {\n    console.debug('Reset count');\n    this.value = 0;\n    this.tick();\n  }\n\n  /**\n   * Tick once and increment the value by 1.\n   */\n  update() {\n    this.tick();\n    this.value += 1;\n  }\n\n  /**\n   * Invoke the tick callback with the current value.\n   */\n  tick() {\n    this.tickCb(this.value);\n    this.emitter.emit('tick', this.value);\n  }\n\n  registerListener(tickCb) {\n    this.emitter.on('tick', tickCb);\n  }\n\n  stopListening(tickCb) {\n    this.emitter.off('tick', tickCb);\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/audio/tools.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 373,
    "kind": "variable",
    "name": "ee",
    "memberof": "src/audio/tools.js",
    "static": true,
    "longname": "src/audio/tools.js~ee",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/audio/tools.js",
    "importStyle": null,
    "description": "ITSLanguage Javascript helper tools.",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@overview",
        "tagValue": "This is part of the ITSLanguage Javascript SDK to perform helper functions."
      },
      {
        "tagName": "@copyright",
        "tagValue": "(c) 2014 ITSLanguage"
      },
      {
        "tagName": "@license",
        "tagValue": "MIT"
      },
      {
        "tagName": "@author",
        "tagValue": "d-centralize"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 374,
    "kind": "class",
    "name": "Stopwatch",
    "memberof": "src/audio/tools.js",
    "static": true,
    "longname": "src/audio/tools.js~Stopwatch",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/audio/tools.js",
    "importStyle": "Stopwatch",
    "description": "A simple stopwatch that ticks every 100 ms. It can be bound to an {@link AudioPlayer} or\n{@link AudioRecorder} which binds the stop and playing functionality to the stopping and starting\nof the Watch. It can also be listened to by other entities.",
    "lineNumber": 20,
    "experimental": "When binding to an Audio Recorder, the stopwatch is not always synced properly. A\ndifference of 0.1s or 0.2s too high may occur when counting. When binding to an Audio Player\nhowever, the timer will sync properly and show the correct duration of the loaded audio file.",
    "interface": false
  },
  {
    "__docId__": 375,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/audio/tools.js~Stopwatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "tickCb",
        "description": "The callback that is invoked on every tick (every 100ms)."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If tickCb is missing."
      }
    ]
  },
  {
    "__docId__": 376,
    "kind": "member",
    "name": "interval",
    "memberof": "src/audio/tools.js~Stopwatch",
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#interval",
    "access": "private",
    "description": "",
    "lineNumber": 34,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 377,
    "kind": "member",
    "name": "value",
    "memberof": "src/audio/tools.js~Stopwatch",
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#value",
    "access": "private",
    "description": "",
    "lineNumber": 40,
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 378,
    "kind": "member",
    "name": "tickCb",
    "memberof": "src/audio/tools.js~Stopwatch",
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#tickCb",
    "access": "private",
    "description": "",
    "lineNumber": 46,
    "type": {
      "nullable": null,
      "types": [
        "Function"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 379,
    "kind": "member",
    "name": "emitter",
    "memberof": "src/audio/tools.js~Stopwatch",
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#emitter",
    "access": "private",
    "description": "",
    "lineNumber": 52,
    "type": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 380,
    "kind": "method",
    "name": "start",
    "memberof": "src/audio/tools.js~Stopwatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#start",
    "access": "public",
    "description": "Start counting and tick every 100 ms.",
    "lineNumber": 58,
    "params": [],
    "return": null
  },
  {
    "__docId__": 382,
    "kind": "method",
    "name": "stop",
    "memberof": "src/audio/tools.js~Stopwatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#stop",
    "access": "public",
    "description": "Stop counting.",
    "lineNumber": 70,
    "params": [],
    "return": null
  },
  {
    "__docId__": 384,
    "kind": "method",
    "name": "reset",
    "memberof": "src/audio/tools.js~Stopwatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#reset",
    "access": "public",
    "description": "Reset count to 0.",
    "lineNumber": 80,
    "params": [],
    "return": null
  },
  {
    "__docId__": 386,
    "kind": "method",
    "name": "update",
    "memberof": "src/audio/tools.js~Stopwatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#update",
    "access": "public",
    "description": "Tick once and increment the value by 1.",
    "lineNumber": 89,
    "params": [],
    "return": null
  },
  {
    "__docId__": 388,
    "kind": "method",
    "name": "tick",
    "memberof": "src/audio/tools.js~Stopwatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#tick",
    "access": "public",
    "description": "Invoke the tick callback with the current value.",
    "lineNumber": 97,
    "params": [],
    "return": null
  },
  {
    "__docId__": 389,
    "kind": "method",
    "name": "registerListener",
    "memberof": "src/audio/tools.js~Stopwatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#registerListener",
    "access": "public",
    "description": null,
    "lineNumber": 102,
    "undocument": true,
    "params": [
      {
        "name": "tickCb",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 390,
    "kind": "method",
    "name": "stopListening",
    "memberof": "src/audio/tools.js~Stopwatch",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/tools.js~Stopwatch#stopListening",
    "access": "public",
    "description": null,
    "lineNumber": 106,
    "undocument": true,
    "params": [
      {
        "name": "tickCb",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 391,
    "kind": "file",
    "name": "src/audio/wave-packer.js",
    "content": "/**\n * Packer class for audio packing\n *\n * @private\n */\nexport default class WavePacker {\n  /**\n   * Stop recording audio.\n   *\n   * @param {number} recordingSampleRate - Sample rate of recording. Must be either 48000 or 44100.\n   * @param {number} sampleRate - Sample rate. Must be half or quarter of the recording sample rate.\n   * @param {number} channels - Amount of audio channels. 1 or 2.\n   */\n  init(recordingSampleRate, sampleRate, channels) {\n    this.recordingSampleRate = recordingSampleRate;\n    if ([48000, 44100].indexOf(this.recordingSampleRate) === -1) {\n      throw new Error(\n        '48000 or 44100 are the only supported recordingSampleRates',\n      );\n    }\n\n    this.sampleRate = sampleRate;\n    if ([\n      this.recordingSampleRate,\n      this.recordingSampleRate / 2,\n      this.recordingSampleRate / 4,\n    ].indexOf(this.sampleRate) === -1) {\n      throw new Error(\n        'sampleRate must be equal, half or a quarter of the '\n        + 'recording sample rate',\n      );\n    }\n\n    this.channels = channels;\n    this.recording = false;\n  }\n\n  clear() {\n    this.recLength = 0;\n    this.recBuffersL = [];\n    this.recBuffersR = [];\n  }\n\n  record(left, right) {\n    this.recBuffersL.push(left);\n    this.recBuffersR.push(right);\n    this.recLength += left.length;\n  }\n\n  recordStreaming(left, right, callback) { // eslint-disable-line class-methods-use-this\n    function convertFloat32ToInt16(buffer) {\n      let l = buffer.length;\n      const buf = new Int16Array(l);\n      while (l) {\n        buf[l] = Math.min(1, buffer[l]) * 0x7FFF;\n        l -= 1;\n      }\n      return buf.buffer;\n    }\n    // Both the left and right channel's data is a view (Float32Array)\n    // on top of the buffer (ArrayBuffer). Each buffer's element should\n    // have _value between -1 and 1.\n    // The audio to export are 16 bit PCM samples that are wrapped in\n    // a WAVE file at the server. Therefore convert from float here.\n    const converted = convertFloat32ToInt16(left);\n    callback(converted);\n  }\n\n  exportWAV(callback) {\n    const bufferL = WavePacker.mergeBuffers(this.recBuffersL, this.recLength);\n    const bufferR = WavePacker.mergeBuffers(this.recBuffersR, this.recLength);\n    const interleaved = this.interleave(bufferL, bufferR);\n    const dataview = this.encodeWAV(interleaved);\n    const audioBlob = new Blob([dataview], {\n      type: 'audio/wav',\n    });\n    callback(audioBlob);\n  }\n\n\n  exportMonoWAV(callback) {\n    const bufferL = WavePacker.mergeBuffers(this.recBuffersL, this.recLength);\n    const dataview = this.encodeWAV(bufferL, true);\n    const audioBlob = new Blob([dataview], {\n      type: 'audio/wav',\n    });\n    callback(audioBlob);\n  }\n\n  /**\n   * Wrap the raw audio in a header to make it a WAVE format.\n   *\n   * @see {@link https://ccrma.stanford.edu/courses/422/projects/WaveFormat/}.\n   *\n   * @todo This function should use the {@link createWAVEHeader} function for creating the header.\n   * @param {Array} interleaved - Array of interleaved audio.\n   */\n  encodeWAV(interleaved) {\n    const buffer = new ArrayBuffer(44 + interleaved.length * 2);\n    const view = new DataView(buffer);\n\n    // RIFF chunk descriptor\n    WavePacker.writeUTFBytes(view, 0, 'RIFF');\n    // file length\n    view.setUint32(4, 44 + interleaved.length * 2, true);\n    // RIFF type\n    WavePacker.writeUTFBytes(view, 8, 'WAVE');\n    // FMT sub-chunk\n    WavePacker.writeUTFBytes(view, 12, 'fmt ');\n    // format chunk length\n    view.setUint32(16, 16, true);\n    // sample format (raw)\n    view.setUint16(20, 1, true);\n    // channel count. mono=1, stereo=2\n    view.setUint16(22, this.channels, true);\n    // sample rate\n    view.setUint32(24, this.sampleRate, true);\n    // byte rate (sample rate * block align)\n    view.setUint32(28, this.sampleRate * 2 * this.channels, true);\n    // block align (channel count * bytes per sample)\n    view.setUint16(32, this.channels * 2, true);\n    // bits per sample\n    view.setUint16(34, 16, true);\n    // data sub-chunk\n    WavePacker.writeUTFBytes(view, 36, 'data');\n    view.setUint32(40, interleaved.length * 2, true);\n\n    // write the PCM samples\n    const lng = interleaved.length;\n    let index = 44;\n    const volume = 1;\n    for (let i = 0; i < lng; i += 1) {\n      view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);\n      index += 2;\n    }\n\n    // Wrap in HTML5 Blob for transport\n    const blob = new Blob([view], {\n      type: 'audio/wav',\n    });\n    console.log(`Recorded audio/wav Blob size: ${blob.size}`);\n    return blob;\n  }\n\n  interleave(leftChannel, rightChannel) {\n    let channelLength = 0;\n    let inputIndex = 0;\n    let result = null;\n    let i = 0;\n\n    if (this.channels === 1) {\n      // Keep both right and left input channels, but \"pan\" them both\n      // in the center (to the single mono channel)\n      channelLength = leftChannel.length;\n      result = new Float32Array(channelLength);\n      for (i = 0; i < leftChannel.length; i += 1) {\n        result[i] = 0.5 * (leftChannel[i] + rightChannel[i]);\n      }\n    } else {\n      channelLength = leftChannel.length + rightChannel.length;\n      result = new Float32Array(channelLength);\n\n      for (i = 0; i < channelLength; i += 2) {\n        result[i] = leftChannel[inputIndex];\n        result[i + 1] = rightChannel[inputIndex];\n        inputIndex += 1;\n      }\n    }\n\n    // Also downsample if needed.\n    if (this.recordingSampleRate !== this.sampleRate) {\n      // E.g. 44100/11025 = 4\n      const reduceBy = this.recordingSampleRate / this.sampleRate;\n      const resampledResult = new Float32Array(channelLength / reduceBy);\n\n      inputIndex = 0;\n      for (i = 0; i < channelLength; i += 1) {\n        let value = 0;\n        for (let j = 0; j < reduceBy; j += 1) {\n          value += result[inputIndex];\n          inputIndex += 1;\n        }\n        resampledResult[i] = 1 / reduceBy * value;\n      }\n      return resampledResult;\n    }\n    return result;\n  }\n\n  static mergeBuffers(channelBuffer, recordingLength) {\n    const result = new Float32Array(recordingLength);\n    let offset = 0;\n    const lng = channelBuffer.length;\n    for (let i = 0; i < lng; i += 1) {\n      const buffer = channelBuffer[i];\n      result.set(buffer, offset);\n      offset += buffer.length;\n    }\n    return result;\n  }\n\n  /**\n   * Deprecated function, will be removed in favor of the pure\n   * {@link wordToUTF8ByteArray} function.\n   *\n   * @deprecated\n   * @param {DataView} view - DataView to write the bytes to.\n   * @param {number} offset - Position in the DataView to start writing from.\n   * @param {string} string - String to write to the DataView.\n   * @returns {void} - Nothing will be returned.\n   */\n  static writeUTFBytes(view, offset, string) {\n    const lng = string.length;\n    for (let i = 0; i < lng; i += 1) {\n      view.setUint8(offset + i, string.charCodeAt(i));\n    }\n  }\n}\n\n/**\n * Get an TypedArray (an Uint8Array to be more precise) that\n * represents a string.\n *\n * @param {string} word - The word to convert.\n * @returns {Uint8Array} - The converted word as Uint8Array.\n */\nexport function wordToUTF8ByteArray(word) {\n  const intArray = [];\n  const { length } = word;\n  let count = 0;\n\n  for (count; count < length; count += 1) {\n    intArray.push(word.charCodeAt(count));\n  }\n\n  return Uint8Array.from(intArray);\n}\n\n/**\n * Composes a PCM WAVE file header.\n * This header will lack any size information, so in effect\n * timing information will most probably be incorrect.\n *\n * More information on the WAVE file specification can be found below.\n * For the SDK and our backend services we use the WAVE PCM format.\n *\n * @see http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html\n * @param {number} channels - Channels in the audio.\n * @param {number} sampleRate - SampleRate of the audio.\n * @returns {ArrayBuffer} - The header as ArrayBuffer.\n */\nexport function createWAVEHeader(channels, sampleRate) {\n  // Default WAVE header length is 44 bytes long.\n  const buffer = new ArrayBuffer(44);\n  const header = new DataView(buffer);\n\n  // Set RIFF chunk descriptor\n  wordToUTF8ByteArray('RIFF').forEach((ui8Int, index) => {\n    header.setUint8(index, ui8Int);\n  });\n\n  // Set RIFF type\n  wordToUTF8ByteArray('WAVE').forEach((ui8Int, index) => {\n    header.setUint8(index + 8, ui8Int);\n  });\n\n  // Set FMT sub-chunk\n  wordToUTF8ByteArray('fmt ').forEach((ui8Int, index) => {\n    header.setUint8(index + 12, ui8Int);\n  });\n\n  // Set format chunk length\n  header.setUint32(16, 16, true);\n\n  // Set sample format (raw)\n  header.setUint16(20, 1, true);\n\n  // Set channel count. mono=1, stereo=2\n  header.setUint16(22, channels, true);\n\n  // Set sample rate\n  header.setUint32(24, sampleRate, true);\n\n  // Set byte rate (sample rate * block align)\n  header.setUint32(28, sampleRate * 2 * channels, true);\n\n  // Set block align (channel count * bytes per sample)\n  header.setUint16(32, channels * 2, true);\n\n  // Set bits per sample\n  header.setUint16(34, 16, true);\n\n  // Set data sub-chunk\n  wordToUTF8ByteArray('data').forEach((ui8Int, index) => {\n    header.setUint8(index + 36, ui8Int);\n  });\n\n  // Return the ArrayBuffer of the header.\n  return header.buffer;\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/audio/wave-packer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 392,
    "kind": "class",
    "name": "WavePacker",
    "memberof": "src/audio/wave-packer.js",
    "static": true,
    "longname": "src/audio/wave-packer.js~WavePacker",
    "access": "private",
    "export": true,
    "importPath": "@itslanguage/sdk/audio/wave-packer.js",
    "importStyle": "WavePacker",
    "description": "Packer class for audio packing",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 393,
    "kind": "method",
    "name": "init",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#init",
    "access": "public",
    "description": "Stop recording audio.",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "recordingSampleRate",
        "description": "Sample rate of recording. Must be either 48000 or 44100."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "sampleRate",
        "description": "Sample rate. Must be half or quarter of the recording sample rate."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "channels",
        "description": "Amount of audio channels. 1 or 2."
      }
    ],
    "return": null
  },
  {
    "__docId__": 394,
    "kind": "member",
    "name": "recordingSampleRate",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#recordingSampleRate",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 395,
    "kind": "member",
    "name": "sampleRate",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#sampleRate",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 396,
    "kind": "member",
    "name": "channels",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#channels",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 397,
    "kind": "member",
    "name": "recording",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#recording",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 398,
    "kind": "method",
    "name": "clear",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#clear",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 399,
    "kind": "member",
    "name": "recLength",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#recLength",
    "access": "public",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 400,
    "kind": "member",
    "name": "recBuffersL",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#recBuffersL",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 401,
    "kind": "member",
    "name": "recBuffersR",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#recBuffersR",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 402,
    "kind": "method",
    "name": "record",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#record",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "params": [
      {
        "name": "left",
        "types": [
          "*"
        ]
      },
      {
        "name": "right",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 404,
    "kind": "method",
    "name": "recordStreaming",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#recordStreaming",
    "access": "public",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "params": [
      {
        "name": "left",
        "types": [
          "*"
        ]
      },
      {
        "name": "right",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 405,
    "kind": "method",
    "name": "exportWAV",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#exportWAV",
    "access": "public",
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 406,
    "kind": "method",
    "name": "exportMonoWAV",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#exportMonoWAV",
    "access": "public",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 407,
    "kind": "method",
    "name": "encodeWAV",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#encodeWAV",
    "access": "public",
    "description": "Wrap the raw audio in a header to make it a WAVE format.",
    "see": [
      "{@link https://ccrma.stanford.edu/courses/422/projects/WaveFormat/}."
    ],
    "lineNumber": 98,
    "todo": [
      "This function should use the {@link createWAVEHeader} function for creating the header."
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "interleaved",
        "description": "Array of interleaved audio."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 408,
    "kind": "method",
    "name": "interleave",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/wave-packer.js~WavePacker#interleave",
    "access": "public",
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "params": [
      {
        "name": "leftChannel",
        "types": [
          "*"
        ]
      },
      {
        "name": "rightChannel",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 409,
    "kind": "method",
    "name": "mergeBuffers",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/audio/wave-packer.js~WavePacker.mergeBuffers",
    "access": "public",
    "description": null,
    "lineNumber": 190,
    "undocument": true,
    "params": [
      {
        "name": "channelBuffer",
        "types": [
          "*"
        ]
      },
      {
        "name": "recordingLength",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 410,
    "kind": "method",
    "name": "writeUTFBytes",
    "memberof": "src/audio/wave-packer.js~WavePacker",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/audio/wave-packer.js~WavePacker.writeUTFBytes",
    "access": "public",
    "description": "Deprecated function, will be removed in favor of the pure\n{@link wordToUTF8ByteArray} function.",
    "lineNumber": 212,
    "deprecated": true,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{void} - Nothing will be returned."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "DataView"
        ],
        "spread": false,
        "optional": false,
        "name": "view",
        "description": "DataView to write the bytes to."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "offset",
        "description": "Position in the DataView to start writing from."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "string",
        "description": "String to write to the DataView."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "void"
      ],
      "spread": false,
      "description": "Nothing will be returned."
    }
  },
  {
    "__docId__": 411,
    "kind": "function",
    "name": "wordToUTF8ByteArray",
    "memberof": "src/audio/wave-packer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/audio/wave-packer.js~wordToUTF8ByteArray",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/audio/wave-packer.js",
    "importStyle": "{wordToUTF8ByteArray}",
    "description": "Get an TypedArray (an Uint8Array to be more precise) that\nrepresents a string.",
    "lineNumber": 227,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Uint8Array} - The converted word as Uint8Array."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "word",
        "description": "The word to convert."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": "The converted word as Uint8Array."
    }
  },
  {
    "__docId__": 412,
    "kind": "function",
    "name": "createWAVEHeader",
    "memberof": "src/audio/wave-packer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/audio/wave-packer.js~createWAVEHeader",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/audio/wave-packer.js",
    "importStyle": "{createWAVEHeader}",
    "description": "Composes a PCM WAVE file header.\nThis header will lack any size information, so in effect\ntiming information will most probably be incorrect.\n\nMore information on the WAVE file specification can be found below.\nFor the SDK and our backend services we use the WAVE PCM format.",
    "see": [
      "http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html"
    ],
    "lineNumber": 252,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ArrayBuffer} - The header as ArrayBuffer."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "channels",
        "description": "Channels in the audio."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "sampleRate",
        "description": "SampleRate of the audio."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayBuffer"
      ],
      "spread": false,
      "description": "The header as ArrayBuffer."
    }
  },
  {
    "__docId__": 413,
    "kind": "file",
    "name": "src/audio/web-audio-player.js",
    "content": "/**\n * ITSLanguage Javascript Audio\n * @overview This is part of the ITSLanguage Javascript SDK to perform audio related functions.\n * @copyright (c) 2014 ITSLanguage\n * @license MIT\n * @author d-centralize\n *\n * This class fires the same events as the HTML5 Audio does.\n * {@link http://www.w3schools.com/tags/ref_av_dom.asp}\n *\n * @private\n */\n\nexport default class WebAudioPlayer {\n  /**\n   * ITSLanguage WebAudioPlayer non-graphical component.\n   *\n   * This player uses the HTML5 Audio component for playback.\n   *\n   * @param {?Object} options - Override any of the default settings.\n   */\n  constructor(options) {\n    this.settings = Object.assign({}, options);\n\n    this.initPlayer();\n  }\n\n  initPlayer() {\n    this.sound = new window.Audio();\n    this.pauseIsStop = false;\n\n    // The its.AudioPlayer API is based upon the same API calls as the\n    // HTML5 Audio element itself, therefore, just bubble up all events.\n    const self = this;\n\n    this.sound.addEventListener('playing', () => {\n      if (self.settings.playingCb) {\n        self.settings.playingCb();\n      }\n    });\n\n    this.sound.addEventListener('timeupdate', () => {\n      if (self.settings.timeupdateCb) {\n        self.settings.timeupdateCb();\n      }\n    });\n\n    this.sound.addEventListener('durationchange', () => {\n      if (self.settings.durationchangeCb) {\n        self.settings.durationchangeCb();\n      }\n    });\n\n    this.sound.addEventListener('canplay', () => {\n      if (self.settings.canplayCb) {\n        self.settings.canplayCb();\n      }\n    });\n\n    this.sound.addEventListener('ended', () => {\n      if (self.settings.endedCb) {\n        self.settings.endedCb();\n      }\n    });\n\n    this.sound.addEventListener('pause', () => {\n      // The HTML5 audio player only has a pause(), no stop().\n      // To differentiate between the two, a flag is set in case the user\n      // explicitly stopped (not paused) the audio.\n      if (self.pauseIsStop === true) {\n        self.pauseIsStop = false;\n        if (self.settings.pauseCb) {\n          self.settings.pauseCb();\n        }\n      } else if (self.settings.stoppedCb) {\n        self.settings.stoppedCb();\n      }\n      if (self.settings.playbackStoppedCb) {\n        self.settings.playbackStoppedCb();\n      }\n    });\n\n    this.sound.addEventListener('progress', () => {\n      if (self.settings.progressCb) {\n        self.settings.progressCb();\n      }\n    });\n\n    this.sound.addEventListener('error', (e) => {\n      switch (e.target.error.code) {\n        case e.target.error.MEDIA_ERR_ABORTED:\n          console.error('You aborted the playback.');\n          break;\n        case e.target.error.MEDIA_ERR_NETWORK:\n          console.error(\n            'A network error caused the audio download to fail.',\n          );\n          break;\n        case e.target.error.MEDIA_ERR_DECODE:\n          console.error(\n            'The audio playback was aborted due to a corruption '\n          + 'problem or because the media used features your '\n          + 'browser did not support.',\n          );\n          break;\n        case e.target.error.MEDIA_ERR_SRC_NOT_SUPPORTED:\n          console.error(\n            'The audio could not be loaded, either because the '\n          + 'server or network failed or because the format is '\n          + 'not supported.',\n          );\n          break;\n        default:\n          console.error('An unknown error occurred.');\n          break;\n      }\n      if (self.settings.errorCb) {\n        self.settings.errorCb();\n      }\n    });\n  }\n\n\n  /**\n   * Preload audio from an URL.\n   *\n   * @param {string} url - The URL that contains the audio.\n   * @param {boolean} [preload=true] - Try preloading metadata and possible some audio (default).\n   * Set to false to not download anything until playing.\n   * @param {Function} [loadedCb] - The callback that is invoked when the duration of the audio file\n   * is first known.\n   */\n  load(url, preload = true, loadedCb) {\n    // Automatically begin buffering the file, even if autoplay is off.\n    this.sound.autobuffer = Boolean(preload);\n\n    // Preloading options:\n    // none - Do not preload any media.\n    // Wait for a play event before downloading anything.\n    // metadata - Preload just the metadata. Grab the start and the end of\n    // the file via range-request and determine the duration.\n    // auto - Preload the whole file. Grab the start and the end of the\n    // file to determine duration, then seek back to the start\n    // again for the preload proper.\n    this.sound.preload = preload ? 'auto' : 'none';\n\n    const self = this;\n    if (loadedCb) {\n      this.sound.addEventListener('durationchange', () => {\n        console.log(`Duration change for ${url} to : ${\n          self.sound.duration}`);\n        loadedCb(self.sound);\n      });\n    }\n\n    this.sound.src = url;\n  }\n\n\n  /**\n   * Start or continue playback of audio.\n   *\n   * @param {?number} position - When position is given, start playing from this position (seconds).\n   */\n  play(position) {\n    if (position !== undefined) {\n      if (this.sound.readyState < this.sound.HAVE_METADATA) {\n        // In case the audio wasn't already preloaded, do it now.\n        this.sound.preload = 'auto';\n        console.warn('Playing from a given position is not possible. '\n          + 'Audio was not yet loaded. Try again.');\n      } else {\n        console.debug(`Scrub position to: ${position}`);\n        this.sound.currentTime = position;\n      }\n    }\n    this.sound.play();\n    console.debug(`Start playing from position: ${this.sound.currentTime}`);\n  }\n\n  /**\n   * Unload previously loaded audio.\n   */\n  reset() {\n    this.initPlayer();\n  }\n\n  /**\n   * Stop playback of audio.\n   */\n  stop() {\n    // The HTML5 audio player only has a pause(), no stop().\n    // To differentiate between the two, set a flag.\n    this.sound.pause();\n    this.sound.currentTime = 0;\n  }\n\n  /**\n   * Pause playback of audio.\n   */\n  pause() {\n    this.pauseIsStop = true;\n    this.sound.pause();\n  }\n\n  /**\n   * Start preloading audio.\n   */\n  preload() {\n    // In case the audio wasn't already preloaded, do it now.\n    if (this.sound.preload !== 'auto') {\n      console.info('Start preloading audio.');\n      this.sound.preload = 'auto';\n    }\n  }\n\n\n  /**\n   * Start playing audio at the given offset.\n   *\n   * @param {number} percentage - Start at this percentage (0..100) of the audio stream.\n   */\n  scrub(percentage) {\n    // In case the audio wasn't already preloaded, do it now.\n    if (this.sound.readyState < this.sound.HAVE_METADATA) {\n      this.preload();\n      console.warn('Scrubbing not possible. Audio was not yet loaded. '\n        + 'Try again.');\n      return;\n    }\n\n    const newTime = this.sound.duration / 100 * percentage;\n    console.log(`Moving audio position to: ${percentage}%: ${\n      newTime}s of total playing time: ${this.sound.duration}`);\n    this.sound.currentTime = newTime;\n  }\n\n  /**\n   * Returns the percentage of which the buffer is filled.\n   *\n   * @returns {number} Percentage of buffer fill.\n   */\n  getBufferFill() {\n    if (this.sound.buffered === undefined\n      || this.sound.buffered.length === 0) {\n      // Nothing buffered yet.\n      return 0;\n    }\n\n    // The fact that there's not one buffer segment is ignored here.\n    // Truly representing the buffered state requires multiple\n    // loading bars.\n    // Usually, when user didn't seek yet, there are two segments:\n    // Got segment from: 0 to: 187.63999938964844\n    // Got segment from: 222.44700622558594 to: 228.1140899658203\n    // The latter is gained when the HTML5 audio component tries to find\n    // the total audio duration.\n    // More info:\n    // http://html5doctor.com/html5-audio-the-state-of-play/#time-ranges\n    let probableEnd = 0;\n    for (let i = 0; i < this.sound.buffered.length; i += 1) {\n      const start = this.sound.buffered.start(i);\n      const end = this.sound.buffered.end(i);\n      // console.log('Got segment from: ' + start + ' to: ' + end);\n      // Often, the segment that starts from 0 keeps growing and\n      // indicates -most likely- the biggest buffer.\n      if (start === 0) {\n        probableEnd = end;\n      }\n    }\n\n    // Round up,so the buffer won't get stuck on 99% when\n    // duration and buffer are equal, except for some far decimal.\n    const loaded = Math.round(probableEnd * 100 / this.sound.duration);\n    console.log(`Buffer filled to ${loaded}%`);\n    return loaded;\n  }\n\n  /**\n   * Returns the current playing time as offset in seconds from the start.\n   *\n   * @returns {number} Time in seconds as offset from the start.\n   */\n  getCurrentTime() {\n    return this.sound.currentTime;\n  }\n\n  /**\n   * Returns the total duration in seconds.\n   *\n   * @returns {number} Time in seconds of fragment duration. 0 if no audio is loaded.\n   */\n  getDuration() {\n    // When no audio is loaded, the duration may be NaN\n    const { duration } = this.sound;\n    return (\n      typeof duration !== 'number'\n      || (typeof duration === 'number' && Number.isNaN(duration)) ? 0 : duration\n    );\n  }\n\n  /**\n   * Returns state of the player.\n   *\n   * @returns {boolean} True when player is currently playing. False when paused or stopped.\n   */\n  isPlaying() {\n    return !this.sound.paused;\n  }\n\n  setPlaybackRate(rate) {\n    this.sound.playbackRate = rate;\n  }\n\n  getPlaybackRate() {\n    return this.sound.playbackRate;\n  }\n\n  /**\n   * Returns ready state of the player.\n   *\n   * @returns {boolean} True when player is ready to start loading data or play. False when no audio\n   * is loaded or preparing.\n   */\n  canPlay() {\n    // Either the player is in a valid readyState (preloaded), or\n    // the player has a source attached and doesn't show any loading error (non-preloaded).\n    return (\n      this.sound.readyState >= this.sound.HAVE_METADATA\n      || (this.sound.src && !this.sound.error)\n    );\n  }\n\n  setAudioVolume(volume) {\n    this.sound.volume = volume;\n  }\n\n  getAudioVolume() {\n    return this.sound.volume;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/audio/web-audio-player.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 414,
    "kind": "class",
    "name": "WebAudioPlayer",
    "memberof": "src/audio/web-audio-player.js",
    "static": true,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer",
    "access": "private",
    "export": true,
    "importPath": "@itslanguage/sdk/audio/web-audio-player.js",
    "importStyle": "WebAudioPlayer",
    "description": "ITSLanguage Javascript Audio",
    "lineNumber": 14,
    "unknown": [
      {
        "tagName": "@overview",
        "tagValue": "This is part of the ITSLanguage Javascript SDK to perform audio related functions."
      },
      {
        "tagName": "@copyright",
        "tagValue": "(c) 2014 ITSLanguage"
      },
      {
        "tagName": "@license",
        "tagValue": "MIT"
      },
      {
        "tagName": "@author",
        "tagValue": "d-centralize\n\nThis class fires the same events as the HTML5 Audio does.\n{@link http://www.w3schools.com/tags/ref_av_dom.asp}"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 415,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#constructor",
    "access": "public",
    "description": "ITSLanguage WebAudioPlayer non-graphical component.\n\nThis player uses the HTML5 Audio component for playback.",
    "lineNumber": 22,
    "params": [
      {
        "nullable": true,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Override any of the default settings."
      }
    ]
  },
  {
    "__docId__": 416,
    "kind": "member",
    "name": "settings",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#settings",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 417,
    "kind": "method",
    "name": "initPlayer",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#initPlayer",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 418,
    "kind": "member",
    "name": "sound",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#sound",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 419,
    "kind": "member",
    "name": "pauseIsStop",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#pauseIsStop",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 420,
    "kind": "method",
    "name": "load",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#load",
    "access": "public",
    "description": "Preload audio from an URL.",
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "url",
        "description": "The URL that contains the audio."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "preload",
        "description": "Try preloading metadata and possible some audio (default).\nSet to false to not download anything until playing."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "loadedCb",
        "description": "The callback that is invoked when the duration of the audio file\nis first known."
      }
    ],
    "return": null
  },
  {
    "__docId__": 421,
    "kind": "method",
    "name": "play",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#play",
    "access": "public",
    "description": "Start or continue playback of audio.",
    "lineNumber": 165,
    "params": [
      {
        "nullable": true,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "position",
        "description": "When position is given, start playing from this position (seconds)."
      }
    ],
    "return": null
  },
  {
    "__docId__": 422,
    "kind": "method",
    "name": "reset",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#reset",
    "access": "public",
    "description": "Unload previously loaded audio.",
    "lineNumber": 184,
    "params": [],
    "return": null
  },
  {
    "__docId__": 423,
    "kind": "method",
    "name": "stop",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#stop",
    "access": "public",
    "description": "Stop playback of audio.",
    "lineNumber": 191,
    "params": [],
    "return": null
  },
  {
    "__docId__": 424,
    "kind": "method",
    "name": "pause",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#pause",
    "access": "public",
    "description": "Pause playback of audio.",
    "lineNumber": 201,
    "params": [],
    "return": null
  },
  {
    "__docId__": 426,
    "kind": "method",
    "name": "preload",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#preload",
    "access": "public",
    "description": "Start preloading audio.",
    "lineNumber": 209,
    "params": [],
    "return": null
  },
  {
    "__docId__": 427,
    "kind": "method",
    "name": "scrub",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#scrub",
    "access": "public",
    "description": "Start playing audio at the given offset.",
    "lineNumber": 223,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "percentage",
        "description": "Start at this percentage (0..100) of the audio stream."
      }
    ],
    "return": null
  },
  {
    "__docId__": 428,
    "kind": "method",
    "name": "getBufferFill",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#getBufferFill",
    "access": "public",
    "description": "Returns the percentage of which the buffer is filled.",
    "lineNumber": 243,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Percentage of buffer fill."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Percentage of buffer fill."
    },
    "params": []
  },
  {
    "__docId__": 429,
    "kind": "method",
    "name": "getCurrentTime",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#getCurrentTime",
    "access": "public",
    "description": "Returns the current playing time as offset in seconds from the start.",
    "lineNumber": 284,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Time in seconds as offset from the start."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Time in seconds as offset from the start."
    },
    "params": []
  },
  {
    "__docId__": 430,
    "kind": "method",
    "name": "getDuration",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#getDuration",
    "access": "public",
    "description": "Returns the total duration in seconds.",
    "lineNumber": 293,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} Time in seconds of fragment duration. 0 if no audio is loaded."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "Time in seconds of fragment duration. 0 if no audio is loaded."
    },
    "params": []
  },
  {
    "__docId__": 431,
    "kind": "method",
    "name": "isPlaying",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#isPlaying",
    "access": "public",
    "description": "Returns state of the player.",
    "lineNumber": 307,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True when player is currently playing. False when paused or stopped."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True when player is currently playing. False when paused or stopped."
    },
    "params": []
  },
  {
    "__docId__": 432,
    "kind": "method",
    "name": "setPlaybackRate",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#setPlaybackRate",
    "access": "public",
    "description": null,
    "lineNumber": 311,
    "undocument": true,
    "params": [
      {
        "name": "rate",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 433,
    "kind": "method",
    "name": "getPlaybackRate",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#getPlaybackRate",
    "access": "public",
    "description": null,
    "lineNumber": 315,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 434,
    "kind": "method",
    "name": "canPlay",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#canPlay",
    "access": "public",
    "description": "Returns ready state of the player.",
    "lineNumber": 325,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True when player is ready to start loading data or play. False when no audio\nis loaded or preparing."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True when player is ready to start loading data or play. False when no audio\nis loaded or preparing."
    },
    "params": []
  },
  {
    "__docId__": 435,
    "kind": "method",
    "name": "setAudioVolume",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#setAudioVolume",
    "access": "public",
    "description": null,
    "lineNumber": 334,
    "undocument": true,
    "params": [
      {
        "name": "volume",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 436,
    "kind": "method",
    "name": "getAudioVolume",
    "memberof": "src/audio/web-audio-player.js~WebAudioPlayer",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-player.js~WebAudioPlayer#getAudioVolume",
    "access": "public",
    "description": null,
    "lineNumber": 338,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 437,
    "kind": "file",
    "name": "src/audio/web-audio-recorder.js",
    "content": "/**\n * WebAudioRecorder.\n * @private\n */\nexport default class WebAudioRecorder {\n  /**\n   * Use 'low level' processing tooling to record audio and get a Wave\n   * (audio/wav) encoded recording.\n   *\n   * Currently supported in all modern HTML5/WebAudio browsers.\n   *\n   * @param {GainNode} source - The source to record.\n   * @param {AudioContext} ctx - The AudioContext to use.\n   * @param {?Function} streamingCallback - The callback to deliver audio chunks to.\n   * @param {WavePacker} packer - Packer to use.\n   */\n  constructor(source, ctx, streamingCallback, packer) {\n    this.recording = false;\n    this.paused = false;\n\n    const context = ctx;\n    // For the best quality, use the samplerate in which audio is recorded.\n    this.recordedSampleRate = context.sampleRate;\n    // var sampleRate = recordedSampleRate;\n    // 48000hz -> 24000hz recording, 44100hz -> 22050hz recording.\n    // Sheffield determined the minimum to be 16000hz, so /4 is too low.\n    this.sampleRate = this.recordedSampleRate / 2;\n    // Streaming doesn't yet downsample: #1302.\n    this.sampleRate = streamingCallback ? this.recordedSampleRate\n      : this.sampleRate;\n\n    // Always record audio in mono.\n    this.channels = 1;\n    console.log(`Recording at: ${\n      this.getAudioSpecs().audioParameters.sampleRate}`);\n\n    this.packer = packer;\n    this.packer.init(this.recordedSampleRate, this.sampleRate, this.channels);\n\n    // From the spec: This value controls how frequently the audioprocess\n    // event is dispatched and how many sample-frames need to be processed\n    // each call. Lower values for buffer size will result in a lower\n    // (better) latency. Higher values will be necessary to avoid audio\n    // breakup and glitches.\n    // Legal values are (256, 512, 1024, 2048, 4096, 8192, 16384).\n    const bufferSize = 8192;\n    const recorder = context.createScriptProcessor(bufferSize, 2, 2);\n    // Keep a reference to the scriptProcessor.\n    // This is a workaround for a bug in Chrome that would otherwise lead to\n    // the recorder being garbage collected before it even recorded anything.\n    // https://bugs.webkit.org/show_bug.cgi?id=112521\n    this.recorder = recorder;\n\n    const self = this;\n    recorder.onaudioprocess = (audioProcessing) => {\n      if (!self.recording) {\n        return;\n      }\n      const left = audioProcessing.inputBuffer.getChannelData(0);\n      const right = audioProcessing.inputBuffer.getChannelData(1);\n      // These returned channel buffers are pointers to the current samples\n      // coming in. Make a snapshot (clone). The webworkers can't serialize\n      // the pointers. Well, Chrome and FF could, but Edge can't.\n      const leftClone = new Float32Array(left);\n      const rightClone = new Float32Array(right);\n      self.packer.record(leftClone, rightClone);\n      if (streamingCallback) {\n        self.packer.recordStreaming(leftClone, rightClone, streamingCallback);\n      }\n    };\n\n    source.connect(recorder);\n    // If the script node is not connected to an output the \"onaudioprocess\"\n    // event is not triggered in chrome.\n    recorder.connect(context.destination);\n  }\n\n  /**\n   * Get the recorded audio specifications.\n   *\n   * @returns {Object} Containing metadata on the audio format.\n   */\n  getAudioSpecs() {\n    return {\n      audioFormat: 'audio/wave',\n      audioParameters: {\n        channels: this.channels,\n        sampleWidth: 16,\n        frameRate: this.sampleRate,\n        sampleRate: this.sampleRate,\n      },\n    };\n  }\n\n  /**\n   * Start recording audio.\n   *\n   */\n  record() {\n    this.packer.clear();\n    this.recording = true;\n    this.paused = false;\n  }\n\n  /**\n   * Request encoded audio to be returned through callback.\n   *\n   * @param {Function} callback - The callback to use when returning the audio as a blob in Wave\n   * format.\n   */\n  getEncodedAudio(callback) {\n    this.packer.exportWAV(callback);\n  }\n\n  /**\n   * Is audio recording in progress.\n   *\n   * @returns {boolean} True when recording. False otherwise.\n   */\n  isRecording() {\n    return this.recording;\n  }\n\n  isPaused() {\n    return this.paused;\n  }\n\n  /**\n   * Stop recording audio.\n   */\n  stop() {\n    this.recording = false;\n    this.paused = false;\n  }\n\n  /**\n   * Pause recording audio.\n   */\n  pause() {\n    this.paused = true;\n    this.recording = false;\n  }\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/audio/web-audio-recorder.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 438,
    "kind": "class",
    "name": "WebAudioRecorder",
    "memberof": "src/audio/web-audio-recorder.js",
    "static": true,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "access": "private",
    "export": true,
    "importPath": "@itslanguage/sdk/audio/web-audio-recorder.js",
    "importStyle": "WebAudioRecorder",
    "description": "WebAudioRecorder.",
    "lineNumber": 5,
    "interface": false
  },
  {
    "__docId__": 439,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#constructor",
    "access": "public",
    "description": "Use 'low level' processing tooling to record audio and get a Wave\n(audio/wav) encoded recording.\n\nCurrently supported in all modern HTML5/WebAudio browsers.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "GainNode"
        ],
        "spread": false,
        "optional": false,
        "name": "source",
        "description": "The source to record."
      },
      {
        "nullable": null,
        "types": [
          "AudioContext"
        ],
        "spread": false,
        "optional": false,
        "name": "ctx",
        "description": "The AudioContext to use."
      },
      {
        "nullable": true,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "streamingCallback",
        "description": "The callback to deliver audio chunks to."
      },
      {
        "nullable": null,
        "types": [
          "WavePacker"
        ],
        "spread": false,
        "optional": false,
        "name": "packer",
        "description": "Packer to use."
      }
    ]
  },
  {
    "__docId__": 440,
    "kind": "member",
    "name": "recording",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#recording",
    "access": "public",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 441,
    "kind": "member",
    "name": "paused",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#paused",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 442,
    "kind": "member",
    "name": "recordedSampleRate",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#recordedSampleRate",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 443,
    "kind": "member",
    "name": "sampleRate",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#sampleRate",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 445,
    "kind": "member",
    "name": "channels",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#channels",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 446,
    "kind": "member",
    "name": "packer",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#packer",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 447,
    "kind": "member",
    "name": "recorder",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#recorder",
    "access": "public",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 448,
    "kind": "method",
    "name": "getAudioSpecs",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#getAudioSpecs",
    "access": "public",
    "description": "Get the recorded audio specifications.",
    "lineNumber": 83,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Object} Containing metadata on the audio format."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Containing metadata on the audio format."
    },
    "params": []
  },
  {
    "__docId__": 449,
    "kind": "method",
    "name": "record",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#record",
    "access": "public",
    "description": "Start recording audio.",
    "lineNumber": 99,
    "params": [],
    "return": null
  },
  {
    "__docId__": 452,
    "kind": "method",
    "name": "getEncodedAudio",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#getEncodedAudio",
    "access": "public",
    "description": "Request encoded audio to be returned through callback.",
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "The callback to use when returning the audio as a blob in Wave\nformat."
      }
    ],
    "return": null
  },
  {
    "__docId__": 453,
    "kind": "method",
    "name": "isRecording",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#isRecording",
    "access": "public",
    "description": "Is audio recording in progress.",
    "lineNumber": 120,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean} True when recording. False otherwise."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True when recording. False otherwise."
    },
    "params": []
  },
  {
    "__docId__": 454,
    "kind": "method",
    "name": "isPaused",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#isPaused",
    "access": "public",
    "description": null,
    "lineNumber": 124,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 455,
    "kind": "method",
    "name": "stop",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#stop",
    "access": "public",
    "description": "Stop recording audio.",
    "lineNumber": 131,
    "params": [],
    "return": null
  },
  {
    "__docId__": 458,
    "kind": "method",
    "name": "pause",
    "memberof": "src/audio/web-audio-recorder.js~WebAudioRecorder",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/audio/web-audio-recorder.js~WebAudioRecorder#pause",
    "access": "public",
    "description": "Pause recording audio.",
    "lineNumber": 139,
    "params": [],
    "return": null
  },
  {
    "__docId__": 461,
    "kind": "file",
    "name": "src/index.js",
    "content": "import * as authentication from './api/auth';\nimport * as basicauth from './api/basicauth';\nimport broadcaster from './api/broadcaster';\nimport * as categories from './api/categories';\nimport * as challenges from './api/challenges';\nimport * as communication from './api/communication';\nimport * as emailauth from './api/emailauth';\nimport * as groups from './api/groups';\nimport * as organisations from './api/organisations';\nimport * as profile from './api/profile';\nimport * as progress from './api/progress';\nimport * as roles from './api/roles';\nimport * as tenants from './api/tenants';\nimport * as users from './api/users';\nimport VolumeMeter, { generateWaveSample } from './audio/audio-tools';\nimport AudioPlayer from './audio/audio-player';\nimport AudioRecorder from './audio/audio-recorder';\nimport Player from './WebAudio/Player';\nimport Stopwatch from './audio/tools';\n\n\n/**\n * Document the version number of the ITSLanguage SDK.\n * @type {string}\n */\nconst VERSION = '4.0.0-beta-8';\n\n\n/**\n * Represents the ITSLanguage SDK.\n * It allows the user to make every call to the API with a single function.\n * @see https://itslanguage.github.io/itslanguage-docs\n */\nexport class Itslanguage {\n  /**\n   * Create ITSLanguage SDK.\n   *\n   * @param {Object} options - An object containing options for communication.\n   * @param {string} options.apiUrl - The URL of the REST api.\n   * @param {string} options.wsUrl - The URL of the WebSocket server.\n   * @param {string} options.authorizationToken - An OAuth2 token string.\n   */\n  constructor(options) {\n    /**\n     * Expose the ITSLanguage SDK version.\n     * @type {string}\n     */\n    this.version = VERSION;\n\n    this.authentication = authentication;\n    this.basicauth = basicauth;\n    this.broadcaster = broadcaster;\n    this.categories = categories;\n    this.challenges = challenges;\n    this.communication = communication;\n    this.emailauth = emailauth;\n    this.groups = groups;\n    this.organisations = organisations;\n    this.profile = profile;\n    this.progress = progress;\n    this.roles = roles;\n    this.tenants = tenants;\n    this.users = users;\n\n    this.utils = {\n      generateWaveSample,\n      VolumeMeter,\n      AudioPlayer,\n      AudioRecorder,\n      Stopwatch,\n      Player,\n    };\n\n    this.communication.updateSettings(options);\n  }\n}\n\n/**\n * Create the ITSLanguage SDK object to interact with the API.\n *\n * @param {Object} options - An object containing options for communication.\n * @param {string} options.apiUrl - The URL of the REST api.\n * @param {string} options.wsUrl - The URL of the Websocket server.\n * @param {string} options.authorizationToken - An OAuth2 token string.\n *\n * @return {Itslanguage} - The SDK.\n */\nexport function createItslSdk(options) {\n  return new Itslanguage(options);\n}\n\n\n/**\n * Factory to create a VolumeMeter.\n * The VolumeMeter object is also available through the ITSLanguage SDK object.\n *\n * @param {AudioContext} audioContext - The WebAudio context.\n * @param {MediaStream} inputStream - The MediaStream to analyze.\n *\n * @returns {VolumeMeter} - A VolumeMeter instance.\n */\nexport function createVolumeMeter(audioContext, inputStream) {\n  return new VolumeMeter(audioContext, inputStream);\n}\n\n\n/**\n * Factory to create an AudioPlayer object.\n * The AudioPlayer object is also available through the ITSLanguage SDK object.\n *\n * @param {Object} options - An object to be able to override default settings for the player.\n * @returns {AudioPlayer} - An AudioPlayer instance.\n */\nexport function createAudioPlayer(options) {\n  return new AudioPlayer(options);\n}\n\n\n/**\n * Factory to create an AudioRecorder object.\n *\n * @param {Object} options - An object to be able to override default settings for the recorder.\n * @returns {AudioRecorder} - An AudioRecorder instance.\n */\nexport function createAudioRecorder(options) {\n  return new AudioRecorder(options);\n}\n\n\n/**\n * Factory to create a Stopwatch object.\n * The StopWatch object is also available through the ITSLanguage SDK object.\n *\n * @param {function} tickCb - Callback function to call at every tick.\n * @returns {Stopwatch} - An instance of the StopWatch object.\n */\nexport function createStopwatch(tickCb) {\n  return new Stopwatch(tickCb);\n}\n\n\n/**\n * Factory to create a Player object. The Player differs from the AudioPlayer in terms that this\n * player uses MediaStream to playback audio instead of the `audio` player.\n * The Player object is also available through the ITSLanguage SDK object.\n *\n * @returns {Player} - An instance of a Player object.\n */\nexport function createPlayer() {\n  return new Player();\n}\n",
    "static": true,
    "longname": "/home/travis/build/itslanguage/itslanguage-js/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 462,
    "kind": "variable",
    "name": "VERSION",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~VERSION",
    "access": "public",
    "export": false,
    "importPath": "@itslanguage/sdk/@itslanguage/sdk",
    "importStyle": null,
    "description": "Document the version number of the ITSLanguage SDK.",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 463,
    "kind": "class",
    "name": "Itslanguage",
    "memberof": "src/index.js",
    "static": true,
    "longname": "src/index.js~Itslanguage",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/@itslanguage/sdk",
    "importStyle": "{Itslanguage}",
    "description": "Represents the ITSLanguage SDK.\nIt allows the user to make every call to the API with a single function.",
    "see": [
      "https://itslanguage.github.io/itslanguage-docs"
    ],
    "lineNumber": 34,
    "interface": false
  },
  {
    "__docId__": 464,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/index.js~Itslanguage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/index.js~Itslanguage#constructor",
    "access": "public",
    "description": "Create ITSLanguage SDK.",
    "lineNumber": 43,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "An object containing options for communication."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.apiUrl",
        "description": "The URL of the REST api."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.wsUrl",
        "description": "The URL of the WebSocket server."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.authorizationToken",
        "description": "An OAuth2 token string."
      }
    ]
  },
  {
    "__docId__": 465,
    "kind": "member",
    "name": "version",
    "memberof": "src/index.js~Itslanguage",
    "static": false,
    "longname": "src/index.js~Itslanguage#version",
    "access": "public",
    "description": "Expose the ITSLanguage SDK version.",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 466,
    "kind": "member",
    "name": "authentication",
    "memberof": "src/index.js~Itslanguage",
    "static": false,
    "longname": "src/index.js~Itslanguage#authentication",
    "access": "public",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 467,
    "kind": "member",
    "name": "basicauth",
    "memberof": "src/index.js~Itslanguage",
    "static": false,
    "longname": "src/index.js~Itslanguage#basicauth",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 468,
    "kind": "member",
    "name": "broadcaster",
    "memberof": "src/index.js~Itslanguage",
    "static": false,
    "longname": "src/index.js~Itslanguage#broadcaster",
    "access": "public",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 469,
    "kind": "member",
    "name": "categories",
    "memberof": "src/index.js~Itslanguage",
    "static": false,
    "longname": "src/index.js~Itslanguage#categories",
    "access": "public",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 470,
    "kind": "member",
    "name": "challenges",
    "memberof": "src/index.js~Itslanguage",
    "static": false,
    "longname": "src/index.js~Itslanguage#challenges",
    "access": "public",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 471,
    "kind": "member",
    "name": "communication",
    "memberof": "src/index.js~Itslanguage",
    "static": false,
    "longname": "src/index.js~Itslanguage#communication",
    "access": "public",
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 472,
    "kind": "member",
    "name": "emailauth",
    "memberof": "src/index.js~Itslanguage",
    "static": false,
    "longname": "src/index.js~Itslanguage#emailauth",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 473,
    "kind": "member",
    "name": "groups",
    "memberof": "src/index.js~Itslanguage",
    "static": false,
    "longname": "src/index.js~Itslanguage#groups",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 474,
    "kind": "member",
    "name": "organisations",
    "memberof": "src/index.js~Itslanguage",
    "static": false,
    "longname": "src/index.js~Itslanguage#organisations",
    "access": "public",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 475,
    "kind": "member",
    "name": "profile",
    "memberof": "src/index.js~Itslanguage",
    "static": false,
    "longname": "src/index.js~Itslanguage#profile",
    "access": "public",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 476,
    "kind": "member",
    "name": "progress",
    "memberof": "src/index.js~Itslanguage",
    "static": false,
    "longname": "src/index.js~Itslanguage#progress",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 477,
    "kind": "member",
    "name": "roles",
    "memberof": "src/index.js~Itslanguage",
    "static": false,
    "longname": "src/index.js~Itslanguage#roles",
    "access": "public",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 478,
    "kind": "member",
    "name": "tenants",
    "memberof": "src/index.js~Itslanguage",
    "static": false,
    "longname": "src/index.js~Itslanguage#tenants",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 479,
    "kind": "member",
    "name": "users",
    "memberof": "src/index.js~Itslanguage",
    "static": false,
    "longname": "src/index.js~Itslanguage#users",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 480,
    "kind": "member",
    "name": "utils",
    "memberof": "src/index.js~Itslanguage",
    "static": false,
    "longname": "src/index.js~Itslanguage#utils",
    "access": "public",
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "type": {
      "types": [
        "{\"generateWaveSample\": *, \"VolumeMeter\": *, \"AudioPlayer\": *, \"AudioRecorder\": *, \"Stopwatch\": *, \"Player\": *}"
      ]
    }
  },
  {
    "__docId__": 481,
    "kind": "function",
    "name": "createItslSdk",
    "memberof": "src/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~createItslSdk",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/@itslanguage/sdk",
    "importStyle": "{createItslSdk}",
    "description": "Create the ITSLanguage SDK object to interact with the API.",
    "lineNumber": 88,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "An object containing options for communication."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.apiUrl",
        "description": "The URL of the REST api."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.wsUrl",
        "description": "The URL of the Websocket server."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.authorizationToken",
        "description": "An OAuth2 token string."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Itslanguage"
      ],
      "spread": false,
      "description": "The SDK."
    }
  },
  {
    "__docId__": 482,
    "kind": "function",
    "name": "createVolumeMeter",
    "memberof": "src/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~createVolumeMeter",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/@itslanguage/sdk",
    "importStyle": "{createVolumeMeter}",
    "description": "Factory to create a VolumeMeter.\nThe VolumeMeter object is also available through the ITSLanguage SDK object.",
    "lineNumber": 102,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{VolumeMeter} - A VolumeMeter instance."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "AudioContext"
        ],
        "spread": false,
        "optional": false,
        "name": "audioContext",
        "description": "The WebAudio context."
      },
      {
        "nullable": null,
        "types": [
          "MediaStream"
        ],
        "spread": false,
        "optional": false,
        "name": "inputStream",
        "description": "The MediaStream to analyze."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "VolumeMeter"
      ],
      "spread": false,
      "description": "A VolumeMeter instance."
    }
  },
  {
    "__docId__": 483,
    "kind": "function",
    "name": "createAudioPlayer",
    "memberof": "src/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~createAudioPlayer",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/@itslanguage/sdk",
    "importStyle": "{createAudioPlayer}",
    "description": "Factory to create an AudioPlayer object.\nThe AudioPlayer object is also available through the ITSLanguage SDK object.",
    "lineNumber": 114,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{AudioPlayer} - An AudioPlayer instance."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "An object to be able to override default settings for the player."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "AudioPlayer"
      ],
      "spread": false,
      "description": "An AudioPlayer instance."
    }
  },
  {
    "__docId__": 484,
    "kind": "function",
    "name": "createAudioRecorder",
    "memberof": "src/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~createAudioRecorder",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/@itslanguage/sdk",
    "importStyle": "{createAudioRecorder}",
    "description": "Factory to create an AudioRecorder object.",
    "lineNumber": 125,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{AudioRecorder} - An AudioRecorder instance."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "An object to be able to override default settings for the recorder."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "AudioRecorder"
      ],
      "spread": false,
      "description": "An AudioRecorder instance."
    }
  },
  {
    "__docId__": 485,
    "kind": "function",
    "name": "createStopwatch",
    "memberof": "src/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~createStopwatch",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/@itslanguage/sdk",
    "importStyle": "{createStopwatch}",
    "description": "Factory to create a Stopwatch object.\nThe StopWatch object is also available through the ITSLanguage SDK object.",
    "lineNumber": 137,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Stopwatch} - An instance of the StopWatch object."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "tickCb",
        "description": "Callback function to call at every tick."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Stopwatch"
      ],
      "spread": false,
      "description": "An instance of the StopWatch object."
    }
  },
  {
    "__docId__": 486,
    "kind": "function",
    "name": "createPlayer",
    "memberof": "src/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/index.js~createPlayer",
    "access": "public",
    "export": true,
    "importPath": "@itslanguage/sdk/@itslanguage/sdk",
    "importStyle": "{createPlayer}",
    "description": "Factory to create a Player object. The Player differs from the AudioPlayer in terms that this\nplayer uses MediaStream to playback audio instead of the `audio` player.\nThe Player object is also available through the ITSLanguage SDK object.",
    "lineNumber": 149,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Player} - An instance of a Player object."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Player"
      ],
      "spread": false,
      "description": "An instance of a Player object."
    },
    "params": []
  },
  {
    "kind": "index",
    "content": "# ITSLanguage JavaScript SDK\n\nSpeech technology for language education.\n\n[![Build Status][build logo]][travis]\n\nThis JavaScript SDK aims to help our customers to build applications for the [ITSLanguage] platform.\nIt provides an easy interface to communicate with our [REST and WebSocket API]. For that purpose we\nmade use of many ES2015 features. Also Promises notation is used a lot to help dealing with\nasynchronous code.\n\n## Requirements\n\nThe JavaScript SDK was build with the browser in mind. However any JavaScript project can use this\nSDK to build applications for the ITSLanguage platform. There are of course a few things to keep in\nmind when not developing for the browser. Our own development on the SDK is based on browser usage.\nWe don't extensively test on other platforms. Do let us know if something is not working by using\nthe issue tracker here. And of course, we accept pull requests!\n\nITSLanguage JavaScript SDK uses:\n\n1. [The `fetch` API][MDN fetch]\n1. [URLSearchParams][MDN URLSearchParams]\n1. [FormData][MDN FormData]\n1. [WebSocket][MDN WebSocket]\n\nIt is expected that these are accessible through their `global` accessors (i.e. by simply calling\n`new FormData()`, `fetch(...)`, etc.).\n\nModern browsers support these (at least to the capacity we use it). Older browsers as well as `Node`\ndon't necessarily support these because the are, as of writing this, still seen as experimental \n(browser) features. They are living standards and therefore expected to be implemented in the \nfuture.\n\nIn the mean time; you might want to look at a few libraries which will add these APIs to your\nenvironment. Here are a few we found useful.\n\n### Browser\n\n- [whatwg-fetch][NPM whatwg-fetch]\n- [url-search-params-polyfill][NPM url-search-params-polyfill]\n\n### Node.js\n\n- [node-fetch][NPM node-fetch]\n- [url-search-params][NPM url-search-params]\n- [form-data][NPM form-data]\n\n#### Both\n\n- [isomorphic-fetch][NPM isomorphic-fetch]\n\n## Installation\n\nThe ITSLanguage Javascript SDK will be distributed as a [npm package]. Package managers that can\nread this registry (like [npm] and [yarn]) can be used to add the SDK to your project's package.json\nfile. For simplicity this readme assumes [npm] as package manager.\n \nAdding ITSLanguage into your project is as easy as instructing [npm] to do so. This will\nautomatically add an entry in your package.json file. If not, you are probably using an older [npm]\nversion (< 5.x). Consider upgrading to at least > 5.x. \n\n```shell\nnpm install @itslanguage/sdk\n```\n\n**note**: While we describe SDK usage through [npm], the ITSLanguage SDK itself is build with usage\nof [yarn] in favor of [npm]. For using the SDK in your project [yarn] is not an requirement. You can\nuse the package manager which is most comfortable for you and your project.\n\n## Usage\n\nAt its highest level one can import a factory method to instantiate the SDK. The object created can\nthen be used to access all other SDK functions. For us this has been found the most common use case.\nIt is possible of course to import specific features at your own need.\n\nSo the next code snippet will demonstrate all you need to import to get started.\n\n```js\n// Import the SDK\nimport { createItslSdk } from '@itslanguage/sdk';\n\n// Instantiate the SDK object\nconst itslSdk = createItslSdk();\n```\n\n### Pre-requirements\n\nTo be able to communicate with our backend servers it is (obviously) required to know the url's to\nconnect to. As part of a user registration we will provide you with the details to get started with.\nFor demonstration purposes we use the following details:\n\nConnection details\n- REST API url: https://api.itslanguage.io (not real)\n- WebSocket API url: wss://ws.itslanguage.io (not real)\n\nAuthentication details\n- Tenant: `demo-tenant`\n- Organisation: `demo-school`\n- Student user: `student`\n- Student password: `student`\n\n### Example: authenticate as a student\n\nAuthentication to our backend means you need to get an access token. This token can then be used to\nperform certain actions, based on the permission a certain role has. Each user has one or more\nroles.\n\nFor more information about [roles], [permissions] and or [access tokens] consult our API docs.\n\nYou can use the SDK to obtain the access token, or you can pass the access token yourself to the\nfactory function. In the next example we will instruct the SDK to get the token for us. The SDK will\nthen store the token so next requests will automatically use the previously obtained token. \n\n```js\n\nimport { createItslSdk } from '@itslanguage/sdk';\n\n// Prepare the options\nconst options = {\n  apiUrl: 'https://api.itslanguage.io',\n  wsUrl: 'wss://ws.itslanguage.io',\n};\n\n// Instantiate the SDK object\nconst itslSdk = createItslSdk(options);\n\n// Prepare a user scope\nconst scope = itslSdk.authentication.assembleScope('demo-tenant', 'demo-school', 'student');\n\n// Authenticate to our backend, returns a promise\nconst auth = itslSdk.authentication.authenticate('student', 'student-password', scope);\n\nauth.then((authResult) => {\n  console.log(authResult); // Will output the token, user and scope for the user obtained.\n});\n\n```\n\n### Example: get current user details\n\nAs said in the previous example, it is also possible to pass a previously obtained token to the SDK.\nLets get the current user details from the server.\n\nFor more information about the [current user] consult our API docs. \n\nThe following example presumes the token to use is `wubbaLubbaDubDub-token`. This token is already\nvalid for a user with a valid scope. \n\n```js\n\nimport { createItslSdk } from '@itslanguage/sdk';\n\n// Prepare the options\nconst options = {\n  apiUrl: 'https://api.itslanguage.io',\n  wsUrl: 'wss://ws.itslanguage.io',\n  authorizationToken: 'wubbaLubbaDubDub-token',\n};\n\n// Instantiate the SDK object\nconst itslSdk = createItslSdk(options);\n\nitslSdk.users.getCurrent().then((currentUser) => {\n  console.log(currentUser); // Will output the details of the current user.\n});\n\n```\n\n[build logo]: https://travis-ci.org/itslanguage/itslanguage-js.svg?branch=master\n[travis]: https://travis-ci.org/itslanguage/itslanguage-js\n[ITSLanguage]: https://www.itslanguage.nl\n[REST and WebSocket API]: https://itslanguage.github.io/itslanguage-docs\n[npm]: https://www.npmjs.com/get-npm\n[yarn]: https://yarnpkg.com\n[npm package]: https://npmjs.org/package/@itslanguage/sdk\n[MDN fetch]: https://developer.mozilla.org/en/docs/Web/API/Fetch_API\n[MDN URLSearchParams]: https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n[MDN FormData]: https://developer.mozilla.org/en-US/docs/Web/API/FormData\n[MDN WebSocket]: https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n[NPM isomorphic-fetch]: https://www.npmjs.com/package/isomorphic-fetch\n[NPM form-data]: https://www.npmjs.com/package/form-data\n[NPM node-fetch]: https://www.npmjs.com/package/node-fetch\n[NPM url-search-params]: https://www.npmjs.com/package/url-search-params\n[NPM whatwg-fetch]: https://www.npmjs.com/package/whatwg-fetch\n[NPM url-search-params-polyfill]: https://www.npmjs.com/package/url-search-params-polyfill\n[roles]: https://itslanguage.github.io/itslanguage-docs/api/roles/index.html\n[permissions]: https://itslanguage.github.io/itslanguage-docs/api/permissions/index.html\n[access tokens]: https://itslanguage.github.io/itslanguage-docs/api/oauth2/index.html\n[current user]: https://itslanguage.github.io/itslanguage-docs/api/users/index.html#get-current-user\n",
    "longname": "/home/travis/build/itslanguage/itslanguage-js/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"@itslanguage/sdk\",\n  \"version\": \"4.0.0-beta-10\",\n  \"private\": true,\n  \"description\": \"The core JavaScript SDK for ITSLanguage.\",\n  \"main\": \"src/index.js\",\n  \"modules\": \"src/index.js\",\n  \"files\": [\n    \"LICENSE\",\n    \"package.json\",\n    \"README.md\",\n    \"src/\"\n  ],\n  \"engines\": {\n    \"npm\": \">=5\",\n    \"node\": \">=8\"\n  },\n  \"scripts\": {\n    \"npmcheckversion\": \"node ./internals/scripts/npmcheckversion.js\",\n    \"preinstall\": \"npm run npmcheckversion\",\n    \"build\": \"node ./internals/scripts/build.js\",\n    \"postbuild\": \"npm run esdoc && ncp ./esdoc ./build/docs\",\n    \"esdoc\": \"esdoc -c esdoc.json\",\n    \"esdoc:clean\": \"rimraf ./esdoc\",\n    \"lint\": \"npm run lint:js\",\n    \"lint:eslint\": \"eslint --ignore-path .gitignore --fix\",\n    \"lint:js\": \"npm run lint:eslint -- . \",\n    \"lint:staged\": \"lint-staged\",\n    \"test\": \"cross-env NODE_ENV=test karma start --single-run --color\",\n    \"test:clean\": \"rimraf ./coverage\",\n    \"clean:all\": \"npm run build:clean && npm run esdoc:clean && npm run test:clean\"\n  },\n  \"lint-staged\": {\n    \"*.js\": [\n      \"eslint --ignore-path .gitignore --fix\",\n      \"git add\"\n    ]\n  },\n  \"pre-commit\": \"lint:staged\",\n  \"author\": \"ITSLanguage (https://www.itslanguage.nl) <support@d-centralize.nl>\",\n  \"contributors\": [\n    \"Mathijs van den Worm <mathijs@d-centralize.nl>\",\n    \"Jogchum Koerts <jogchum.koerts@itslanguage.nl>\",\n    \"Loek Ehren <loek-ehren@hotmail.com>\"\n  ],\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/itslanguage/itslanguage-js.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/itslanguage/itslanguage-js/issues\"\n  },\n  \"homepage\": \"https://github.com/itslanguage/itslanguage-js#readme\",\n  \"dependencies\": {\n    \"autobahn\": \"0.11.2\",\n    \"debug\": \"4.1.0\",\n    \"event-emitter\": \"0.3.5\",\n    \"pcmjs\": \"0.0.2\",\n    \"uuid\": \"3.3.2\"\n  },\n  \"devDependencies\": {\n    \"@babel/cli\": \"7.1.2\",\n    \"@babel/core\": \"7.1.2\",\n    \"@babel/plugin-proposal-class-properties\": \"7.1.0\",\n    \"@babel/preset-env\": \"7.1.0\",\n    \"babel-eslint\": \"10.0.1\",\n    \"babel-plugin-istanbul\": \"5.0.1\",\n    \"babelify\": \"10.0.0\",\n    \"browserify\": \"16.2.3\",\n    \"cross-env\": \"5.2.0\",\n    \"esdoc\": \"1.1.0\",\n    \"esdoc-ecmascript-proposal-plugin\": \"1.0.0\",\n    \"esdoc-importpath-plugin\": \"1.0.2\",\n    \"esdoc-standard-plugin\": \"1.0.0\",\n    \"eslint\": \"5.7.0\",\n    \"eslint-config-airbnb-base\": \"13.1.0\",\n    \"eslint-plugin-import\": \"2.14.0\",\n    \"eslint-plugin-jsdoc\": \"3.8.0\",\n    \"fs-extra\": \"7.0.0\",\n    \"jasmine-ajax\": \"3.4.0\",\n    \"jasmine-core\": \"3.2.1\",\n    \"karma\": \"3.0.0\",\n    \"karma-browserify\": \"5.3.0\",\n    \"karma-chrome-launcher\": \"2.2.0\",\n    \"karma-coverage\": \"1.1.2\",\n    \"karma-jasmine\": \"1.1.2\",\n    \"lint-staged\": \"7.3.0\",\n    \"ncp\": \"2.0.0\",\n    \"pre-commit\": \"1.2.2\",\n    \"rimraf\": \"2.6.2\",\n    \"rollup\": \"0.66.6\",\n    \"rollup-plugin-babel\": \"4.0.3\",\n    \"rollup-plugin-babel-minify\": \"6.1.1\",\n    \"rollup-plugin-commonjs\": \"9.2.0\",\n    \"rollup-plugin-json\": \"3.1.0\",\n    \"rollup-plugin-node-builtins\": \"2.1.2\",\n    \"rollup-plugin-node-resolve\": \"3.4.0\",\n    \"rollup-plugin-progress\": \"0.4.0\",\n    \"watchify\": \"3.11.0\"\n  }\n}\n",
    "longname": "/home/travis/build/itslanguage/itslanguage-js/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manualIndex",
    "globalIndex": false,
    "content": "# ITSLanguage Javascript SDK Manual\n\nThis area will contain the manual entries for the ITSLanguage Javascript SDK.\nThis is currently under construction.\n\n\n## Manual ToC\n\n- [Troubleshooting]\n\n[Troubleshooting]: manual/troubleshooting.html\n",
    "longname": "/home/travis/build/itslanguage/itslanguage-js/manual/index.md",
    "name": "./manual/index.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "manual",
    "longname": "/home/travis/build/itslanguage/itslanguage-js/manual/troubleshooting.md",
    "name": "./manual/troubleshooting.md",
    "content": "# Troubleshooting\n\n## Webpack Error: Module not found\n\nThe `ws` module needs to be ignored. In your Webpack configuration, make sure the following is included:\n\n```js\nconst webpack = require('webpack');\n\n\nmodule.exports = {\n  plugins: [\n    webpack.IgnorePlugin(/^ws$/)\n    ...\n  ],\n  ...\n};\n```\n\n\n## Websocket calls are not responding\n\nThe project must be served over SSL.\n\nWhen using `webpack-dev-server`, make sure to add the `--https` flag.\n\nThe browser might show a warning that the website is insecure. Just ignore this warning and continue.\n",
    "static": true,
    "access": "public"
  }
]